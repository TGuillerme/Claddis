plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Test", side = "Girdles", col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?mtext
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2, adj = 1)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?par
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "o")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?par
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, i * 5), y = c(i * 5, 0), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, i * 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, i * 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, i * 1), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, i * 1), y = c(0, i * 1), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 1), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), asp = 1, bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?text
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = c(0, i), y = c(i, 0), labels = paste("C =", i * 2), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i, y = i, labels = paste("C =", i * 2), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i, y = i, labels = paste("C =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i, y = i, labels = paste("C =", i), col = "blue", cex = 1)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = i * 5, y = i * 5, labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = i * 5, y = i * 5, labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
i<-c(0.2, 0.5, 1, 2, 5)
i*5
i <- 10
i <- 5
i * 5
if(i * 5 > 5, 5, i * 5)
ifelse(i * 5 > 5, 5, i * 5)
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse(i * 5 > 5, 5, i * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
"Ammonite_quadrats/", QuadratNumber, ".pdf", sep = "")
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
"Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))
QuadratNumber<-"A1"
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
"Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))
plot(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], type = "n", asp = 1)#
text(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], labels = rownames(UKCityDistances))
?text
plot(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], type = "n", asp = 1)#
text(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], labels = rownames(UKCityDistances), angle = 90)
?par
plot(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], type = "n", asp = 1)#
text(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], labels = rownames(UKCityDistances), srt = 90)
plot(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], type = "n", asp = 1)#
text(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], labels = rownames(UKCityDistances), srt = -90)
plot(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], type = "n", asp = 1)#
text(x = cmdscale(UKCityDistances)[, 1],#
  y = cmdscale(UKCityDistances)[, 2], labels = rownames(UKCityDistances), srt = -45)
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle", alab = expression(lambda[1] == lambda[2]), blab = expression(lambda[2] == lambda[3]), clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points, coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20, cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse(i * 5 > 5, 5, i * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse(i * 5 > 5, 5, i * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
for(i in c(0.2, 0.5, 1, 2, 5)) print(ifelse(i * 5 > 5, 5, i * 5)
)
i / 5
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse(i / 5 > 5, 5, i / 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
for(i in c(0.2, 0.5, 1, 2, 5)) print(ifelse(i / 5 > 5, 5, i / 5))
for(i in c(0.2, 0.5, 1, 2, 5)) print(ifelse(1 / i > 5, 5, 1 / i))
for(i in c(0.2, 0.5, 1, 2, 5)) print(ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5))
for(i in c(0.2, 0.5, 1, 2, 5)) print(plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
#for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)
par(mar = c(2, 2, 2, 2))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?par
par(mar = c(2, 2, 2, 2))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
par(mar = c(5, 5, 5, 5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 2)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 2)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 2)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5)#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?text
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(-1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)
?par
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:3 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l")#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l", xlab = expression(lambda[2] / lambda[3]))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l", xlab = expression(ln(lambda[2] / lambda[3])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
par(mar = c(5, 5, 7.5, 7.5))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l", xlab = expression(ln(lambda[2] / lambda[3])), ylab = expression(ln(lambda[1] / lambda[2])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
par(mar = c(5, 5, 7, 7))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l", xlab = expression(ln(lambda[2] / lambda[3])), ylab = expression(ln(lambda[1] / lambda[2])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
par(mar = c(5, 5, 6, 6))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l", xlab = expression(ln(lambda[2] / lambda[3])), ylab = expression(ln(lambda[1] / lambda[2])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2, lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5), col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i), col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5), y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i), col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
# Before we start begin by setting your working directory.#
#
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "A!"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath#
#
# You cna read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "A1"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath#
#
# You cna read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues
AmmoniteDistanceMatrix <- dist(AmmoniteQuadratValues[,#
  c("X_coordinate", "Y_coordinate")])#
AmmoniteDistanceMatrix
AmmoniteOrdination <- cmdscale(AmmoniteDistanceMatrix)
AmmoniteOrdination
AmmoniteOrdination <- cmdscale(AmmoniteDistanceMatrix, k = 19)
AmmoniteOrdination
?cmdscale
AmmoniteOrdination <- cmdscale(d = AmmoniteDistanceMatrix, k = 19)
AmmoniteOrdination
apply(AmmoniteOrdination, 1, var)
barplot(apply(AmmoniteOrdination, 1, var))
barplot(apply(AmmoniteOrdination, 2, var))
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0, border = 0)
?barplot
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0, border = 0, names.arg = 1:ncol(AmmoniteOrdination))
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0, border = 0, names.arg = 1:ncol(AmmoniteOrdination), ylab = "Ordination axes")
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0, border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")
plot(x = AmmoniteOrdination[, 1],#
  y = AmmoniteOrdination[, 2], type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1],#
  y = AmmoniteOrdination[, 2], labels = 1:20)
plot(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], xlab = "PC1",#
  ylab = "PC2", type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], labels = 1:20)
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))
plot(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], xlab = "PC1",#
  ylab = "PC2", type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], labels = 1:20)
#################################################################################
#                                                                              ##
#                    PRACTICAL IX - MULTIVARIATE STATISTICS                    ##
#                                                                              ##
#################################################################################
#
#################################################################################
#                                                                              ##
#                               TODAY'S AIMS                                   ##
#                                                                              ##
# -   ##
# -   ##
# -   ##
#                                                                              ##
#################################################################################
#
# Before we start begin by setting your working directory.#
#
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "X4"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath#
#
# You can read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues#
#
# These are the ammonites (numbered 1-20), their X and Y coordinates (in#
# millimetres from an origin at the bottom left of the quadrat), their#
# diameters (in millimetres), the number of chambers, and the bearing of their#
# apertures (in degrees). Compare these to your own measurements. You should#
# hopefully find they are very similar. However, you may have found that you#
# were unable to replicate the precision of these values. Don't worry about#
# this as you were working with a smaller scale version and should still have#
# got the right answers we discussed in lecture.#
##
# Before we leave ammonites behind for good we can use their xy coordinates to#
# illustrate one form of multivariate analysis known as "Classic Multi-#
# Dimensional Scaling" (CMDS), sometimes also called "Principal Coordinates".#
# This works by accepting a distance matrix - a matrix the rows and columns#
# represent the same set of objects and the values the distances between them#
# - and turning this into a set of coordinates for those objects. This can be#
# used to do multivariate analysis as those distances can come from as many#
# variables as desired. However, here we are just going to use two - our x and#
# y axes. Note that this is not something we should do with this data, this is#
# simply a way to illustrate the process. We can generate the distance matrix#
# with:#
AmmoniteDistanceMatrix <- dist(AmmoniteQuadratValues[,#
  c("X_coordinate", "Y_coordinate")])#
AmmoniteDistanceMatrix#
#
# Next we can ordinate the data with:#
AmmoniteOrdination <- cmdscale(d = AmmoniteDistanceMatrix, k = 19)#
#
# Here we provide the function with the distance matrix (d) and set the number#
# of axes we will allow the variance to be spread over (k). Here we are#
# allowing the maximum possible (which is N - 1, for N total objects), i.e.,#
# 20 ammonites - 1 = 19. You should see, however, that many of these axes are#
# immediately discarded as their effective variance is zero (i.e., the warning#
# message). You might be wondering why there are more than two axes at all as#
# we know the raw data only requires two axes to plot it. Well you can#
# visually compare the variance across each ordination axis with:#
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")#
#
# What does this show you? Remember that each axis must always have LOWER#
# variance than the preceding one. You should see that from the third axis#
# onwards there is effectively no variance, i.e., the ordination has correctly#
# identified that only two axes are really needed to explain the data. You can#
# plot these with:#
plot(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], xlab = "PC1",#
  ylab = "PC2", type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], labels = 1:20)#
#
# What can you see when you look at this plot? Hint: try comparing it to the#
# raw data with:#
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))#
#
# You should see that there is not a substantial reduction in dimensionality,#
# but the data do not really allow this as the spread of data is roughly#
# equal in all directions - i.e., consistent with the spatial pattern of a#
# uniform distribution we found previously. The other thing you should notice#
# is there is likely some rotation of the data and possibly even a reflection.#
# Remember a rotation is a typical part of the ordination process. If you look#
# at the axis values you should also see some negative values and generally#
# that the new origin (0, 0) sits directly in the centre of the data. Again,#
# what we would expect from an ordination. Now let's look at a similar type of#
# data set, the distance in miles (by road) between several major UK cities:#
UKCityDistances <- matrix(c(0, 239, 53, 252, 174, 80, 181, 82, 65, 194, 97, 25,#
  344, 210, 292, 186, 264, 88, 231, 217, 129, 195, 307, 239, 0, 195, 17, 65,#
  160, 190, 319, 208, 77, 217, 229, 575, 419, 107, 418, 143, 154, 118, 74, 128,#
  198, 538, 53, 95, 0, 208, 130, 38, 146, 128, 38, 160, 72, 34, 385, 241,#
  240, 227, 229, 37, 178, 164, 76, 156, 347, 252, 17, 208, 0, 78, 173, 184,#
  332, 222, 71, 231, 242, 589, 432, 124, 431, 131, 175, 138, 94, 141, 218,#
  552, 174, 65, 130, 78, 0, 95, 141, 254, 144, 56, 153, 164, 511, 354, 141,#
  353, 129, 90, 104, 70, 63, 157, 473, 80, 160, 38, 173, 95, 0, 123, 159, 71,#
  123, 99, 70, 416, 279, 213, 259, 196, 16, 151, 137, 49, 156, 379, 181, 190,#
  146, 184, 141, 123, 0, 260, 185, 112, 217, 174, 517, 383, 282, 360, 156,#
  139, 235, 209, 161, 271, 480, 82, 319, 128, 332, 254, 159, 260, 0, 131,#
  274, 155, 94, 265, 145, 364, 107, 343, 161, 301, 288, 204, 259, 228, 65,#
  208, 38, 222, 144, 71, 185, 131, 0, 184, 34, 41, 371, 214, 238, 213, 257,#
  59, 173, 162, 81, 131, 333, 194, 77, 160, 71, 56, 123, 112, 274, 184, 0,#
  198, 191, 529, 389, 170, 372, 74, 123, 150, 114, 111, 212, 492, 97, 217,#
  72, 231, 153, 99, 217, 155, 34, 198, 0, 73, 372, 216, 237, 214, 270, 81,#
  165, 161, 90, 105, 335, 25, 229, 34, 242, 164, 70, 174, 94, 41, 191, 73, 0,#
  351, 211, 271, 193, 257, 70, 208, 196, 110, 171, 314, 344, 575, 385, 589,#
  511, 416, 517, 265, 371, 529, 372, 351, 0, 167, 602, 158, 600, 419, 530,#
  527, 448, 477, 107, 210, 419, 241, 432, 354, 279, 383, 145, 214, 389, 216,#
  211, 167, 0, 446, 45, 466, 270, 374, 371, 292, 321, 141, 292, 107, 240,#
  124, 141, 213, 282, 364, 238, 170, 237, 271, 602, 446, 0, 444, 244, 203,#
  120, 75, 164, 199, 565, 186, 418, 227, 431, 353, 259, 360, 107, 213, 372,#
  214, 193, 158, 45, 444, 0, 442, 263, 373, 369, 290, 320, 121, 264, 143,#
  229, 131, 129, 196, 156, 343, 257, 74, 270, 257, 600, 466, 244, 442, 0,#
  196, 228, 189, 185, 285, 563, 88, 154, 37, 175, 90, 16, 139, 161, 59, 123,#
  81, 70, 419, 270, 203, 263, 196, 0, 142, 127, 40, 140, 384, 231, 118, 178,#
  138, 104, 151, 235, 301, 173, 150, 165, 208, 530, 374, 120, 373, 228, 142,#
  0, 44, 102, 110, 493, 217, 74, 164, 94, 70, 137, 209, 288, 162, 114, 161,#
  196, 527, 371, 75, 369, 189, 127, 44, 0, 88, 124, 490, 129, 128, 76, 141,#
  63, 49, 161, 204, 81, 111, 90, 110, 448, 292, 164, 290, 185, 40, 102, 88,#
  0, 116, 411, 195, 198, 156, 218, 157, 156, 271, 259, 131, 212, 105, 171,#
  477, 321, 199, 320, 285, 140, 110, 124, 116, 0, 440, 307, 538, 347, 552,#
  473, 379, 480, 228, 333, 492, 335, 314, 107, 141, 565, 121, 563, 384, 493,#
  490, 411, 440, 0),  ncol = 23, dimnames = list(rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York")), rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York"))))#
UKCityDistances
cmdscale(UKCityDistances, k = ncol(UKCityDistances) - 1)
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")
# We can ordinate this with CMDS again:#
UKCityDistanceOrdination <- cmdscale(UKCityDistances,#
  k = ncol(UKCityDistances) - 1)#
#
# You should see, again, that we do not need all the axes of variance we ask#
# for. Let's start by looking at variance across each axis again:#
#
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(UKCityDistanceOrdination), xlab = "Ordination axes")
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance",#
  space = 0, border = 0, names.arg = 1:ncol(UKCityDistanceOrdination),#
  xlab = "Ordination axes")
plot(x = UKCityDistanceOrdination[, 1],#
  y = UKCityDistanceOrdination[, 2], type = "n", asp = 1)#
text(x = UKCityDistanceOrdination[, 1],#
  y = UKCityDistanceOrdination[, 2], labels = rownames(UKCityDistanceOrdination), srt = -45)
plot(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  type = "n", asp = 1)#
text(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  labels = rownames(UKCityDistanceOrdination), srt = -45)
CentralSymbol <-        c(0, 0, 1, 0, 0, 0, 1, 0)#
CrossSymbol <-          c(0, 0, 0, 0, 0, 0, 0, 1)#
HasBlack <-             c(0, 0, 1, 0, 0, 0, 0, 0)#
HasBlue <-              c(1, 1, 0, 0, 0, 1, 0, 1)#
HasGreen <-             c(0, 0, 1, 1, 1, 0, 0, 0)#
HasOrange <-            c(0, 0, 1, 1, 0, 0, 0, 0)#
HasRed <-               c(1, 1, 0, 0, 1, 1, 1, 1)#
HasWhite <-             c(1, 0, 1, 1, 1, 1, 1, 1)#
HasYellow <-            c(0, 1, 0, 0, 0, 0, 0, 0)#
SaltireSymbol <-        c(0, 0, 0, 0, 0, 0, 0, 1)#
ThreeHorizontalBands <- c(0, 1, 1, 0, 0, 1, 0, 0)#
ThreeVerticalBands <-   c(1, 0, 0, 1, 1, 0, 0, 0)#
TotalNColours <-        c(3, 3, 4, 3, 3, 3, 2, 3)#
#
# These can be combined into a single large data matrix with:#
FlagData <- t(matrix(c(CentralSymbol, CrossSymbol, HasBlack, HasBlue,#
  HasGreen, HasOrange, HasRed, HasWhite, HasYellow, SaltireSymbol,#
  ThreeHorizontalBands, ThreeVerticalBands, TotalNColours), ncol = 8,#
  byrow = TRUE, dimnames = list(c("CentralSymbol", "CrossSymbol", "HasBlack",#
  "HasBlue", "HasGreen", "HasOrange", "HasRed", "HasWhite", "HasYellow",#
  "SaltireSymbol", "ThreeHorizontalBands", "ThreeVerticalBands",#
  "TotalNColours"), c("France", "Germany", "India", "Ireland", "Italy",#
  "Netherlands", "Japan", "United Kingdom"))))#
FlagData
FlagDistances <- dist(x = FlagData)#
FlagDistances
FlagDistances <- dist(x = FlagData)#
FlagDistances#
#
# Note that underneath this is just the Pythagorean Theorem we discussed in#
# lecture. Now we can ordinate the data with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances)#
FlagPrincipalCoordinates
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)#
FlagPrincipalCoordinates
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)
FlagDistances <- dist(x = FlagData)#
FlagDistances#
#
# Note that underneath this is just the Pythagorean Theorem we discussed in#
# lecture. Now we can ordinate the data with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)#
#
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates,#
xlab = "Ordination axes")
tribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 3)#
#
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")
plot(x = FlagPrincipalCoordinates[, 1],#
y = FlagPrincipalCoordinates[, 2], type = "n", asp = 1)#
text(x = FlagPrincipalCoordinates[, 1],#
y = FlagPrincipalCoordinates[, 2], labels = rownames(FlagData))
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  labels = rownames(FlagData))
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  labels = rownames(FlagData), srt = -45)
#################################################################################
#                                                                              ##
#                    PRACTICAL IX - MULTIVARIATE STATISTICS                    ##
#                                                                              ##
#################################################################################
#
#################################################################################
#                                                                              ##
#                               TODAY'S AIMS                                   ##
#                                                                              ##
# -   ##
# -   ##
# -   ##
#                                                                              ##
#################################################################################
#
# Before we start begin by setting your working directory.#
#
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "X4"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath#
#
# You can read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues#
#
# These are the ammonites (numbered 1-20), their X and Y coordinates (in#
# millimetres from an origin at the bottom left of the quadrat), their#
# diameters (in millimetres), the number of chambers, and the bearing of their#
# apertures (in degrees). Compare these to your own measurements. You should#
# hopefully find they are very similar. However, you may have found that you#
# were unable to replicate the precision of these values. Don't worry about#
# this as you were working with a smaller scale version and should still have#
# got the right answers we discussed in lecture.#
##
# Before we leave ammonites behind for good we can use their xy coordinates to#
# illustrate one form of multivariate analysis known as "Classic Multi-#
# Dimensional Scaling" (CMDS), sometimes also called "Principal Coordinates".#
# This works by accepting a distance matrix - a matrix the rows and columns#
# represent the same set of objects and the values the distances between them#
# - and turning this into a set of coordinates for those objects. This can be#
# used to do multivariate analysis as those distances can come from as many#
# variables as desired. However, here we are just going to use two - our x and#
# y axes. Note that this is not something we should do with this data, this is#
# simply a way to illustrate the process. We can generate the distance matrix#
# with:#
AmmoniteDistanceMatrix <- dist(AmmoniteQuadratValues[,#
  c("X_coordinate", "Y_coordinate")])#
AmmoniteDistanceMatrix#
#
# Next we can ordinate the data with:#
AmmoniteOrdination <- cmdscale(d = AmmoniteDistanceMatrix, k = 19)#
#
# Here we provide the function with the distance matrix (d) and set the number#
# of axes we will allow the variance to be spread over (k). Here we are#
# allowing the maximum possible (which is N - 1, for N total objects), i.e.,#
# 20 ammonites - 1 = 19. You should see, however, that many of these axes are#
# immediately discarded as their effective variance is zero (i.e., the warning#
# message). You might be wondering why there are more than two axes at all as#
# we know the raw data only requires two axes to plot it. Well you can#
# visually compare the variance across each ordination axis with:#
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")#
#
# What does this show you? Remember that each axis must always have LOWER#
# variance than the preceding one. You should see that from the third axis#
# onwards there is effectively no variance, i.e., the ordination has correctly#
# identified that only two axes are really needed to explain the data. You can#
# plot these with:#
plot(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], xlab = "PC1",#
  ylab = "PC2", type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], labels = 1:20)#
#
# What can you see when you look at this plot? Hint: try comparing it to the#
# raw data with:#
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))#
#
# You should see that there is not a substantial reduction in dimensionality,#
# but the data do not really allow this as the spread of data is roughly#
# equal in all directions - i.e., consistent with the spatial pattern of a#
# uniform distribution we found previously. The other thing you should notice#
# is there is likely some rotation of the data and possibly even a reflection.#
# Remember a rotation is a typical part of the ordination process. If you look#
# at the axis values you should also see some negative values and generally#
# that the new origin (0, 0) sits directly in the centre of the data. Again,#
# what we would expect from an ordination. Now let's look at a similar type of#
# data set, the distance in miles (by road) between several major UK cities:#
UKCityDistances <- matrix(c(0, 239, 53, 252, 174, 80, 181, 82, 65, 194, 97, 25,#
  344, 210, 292, 186, 264, 88, 231, 217, 129, 195, 307, 239, 0, 195, 17, 65,#
  160, 190, 319, 208, 77, 217, 229, 575, 419, 107, 418, 143, 154, 118, 74, 128,#
  198, 538, 53, 95, 0, 208, 130, 38, 146, 128, 38, 160, 72, 34, 385, 241,#
  240, 227, 229, 37, 178, 164, 76, 156, 347, 252, 17, 208, 0, 78, 173, 184,#
  332, 222, 71, 231, 242, 589, 432, 124, 431, 131, 175, 138, 94, 141, 218,#
  552, 174, 65, 130, 78, 0, 95, 141, 254, 144, 56, 153, 164, 511, 354, 141,#
  353, 129, 90, 104, 70, 63, 157, 473, 80, 160, 38, 173, 95, 0, 123, 159, 71,#
  123, 99, 70, 416, 279, 213, 259, 196, 16, 151, 137, 49, 156, 379, 181, 190,#
  146, 184, 141, 123, 0, 260, 185, 112, 217, 174, 517, 383, 282, 360, 156,#
  139, 235, 209, 161, 271, 480, 82, 319, 128, 332, 254, 159, 260, 0, 131,#
  274, 155, 94, 265, 145, 364, 107, 343, 161, 301, 288, 204, 259, 228, 65,#
  208, 38, 222, 144, 71, 185, 131, 0, 184, 34, 41, 371, 214, 238, 213, 257,#
  59, 173, 162, 81, 131, 333, 194, 77, 160, 71, 56, 123, 112, 274, 184, 0,#
  198, 191, 529, 389, 170, 372, 74, 123, 150, 114, 111, 212, 492, 97, 217,#
  72, 231, 153, 99, 217, 155, 34, 198, 0, 73, 372, 216, 237, 214, 270, 81,#
  165, 161, 90, 105, 335, 25, 229, 34, 242, 164, 70, 174, 94, 41, 191, 73, 0,#
  351, 211, 271, 193, 257, 70, 208, 196, 110, 171, 314, 344, 575, 385, 589,#
  511, 416, 517, 265, 371, 529, 372, 351, 0, 167, 602, 158, 600, 419, 530,#
  527, 448, 477, 107, 210, 419, 241, 432, 354, 279, 383, 145, 214, 389, 216,#
  211, 167, 0, 446, 45, 466, 270, 374, 371, 292, 321, 141, 292, 107, 240,#
  124, 141, 213, 282, 364, 238, 170, 237, 271, 602, 446, 0, 444, 244, 203,#
  120, 75, 164, 199, 565, 186, 418, 227, 431, 353, 259, 360, 107, 213, 372,#
  214, 193, 158, 45, 444, 0, 442, 263, 373, 369, 290, 320, 121, 264, 143,#
  229, 131, 129, 196, 156, 343, 257, 74, 270, 257, 600, 466, 244, 442, 0,#
  196, 228, 189, 185, 285, 563, 88, 154, 37, 175, 90, 16, 139, 161, 59, 123,#
  81, 70, 419, 270, 203, 263, 196, 0, 142, 127, 40, 140, 384, 231, 118, 178,#
  138, 104, 151, 235, 301, 173, 150, 165, 208, 530, 374, 120, 373, 228, 142,#
  0, 44, 102, 110, 493, 217, 74, 164, 94, 70, 137, 209, 288, 162, 114, 161,#
  196, 527, 371, 75, 369, 189, 127, 44, 0, 88, 124, 490, 129, 128, 76, 141,#
  63, 49, 161, 204, 81, 111, 90, 110, 448, 292, 164, 290, 185, 40, 102, 88,#
  0, 116, 411, 195, 198, 156, 218, 157, 156, 271, 259, 131, 212, 105, 171,#
  477, 321, 199, 320, 285, 140, 110, 124, 116, 0, 440, 307, 538, 347, 552,#
  473, 379, 480, 228, 333, 492, 335, 314, 107, 141, 565, 121, 563, 384, 493,#
  490, 411, 440, 0),  ncol = 23, dimnames = list(rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York")), rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York"))))#
UKCityDistances#
#
# We can ordinate this with CMDS again:#
UKCityDistanceOrdination <- cmdscale(UKCityDistances,#
  k = ncol(UKCityDistances) - 1)#
#
# You should see, again, that we do not need all the axes of variance we ask#
# for. Let's start by looking at variance across each axis again:#
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance",#
  space = 0, border = 0, names.arg = 1:ncol(UKCityDistanceOrdination),#
  xlab = "Ordination axes")#
#
# We might assume, again, that we only really need two axes here as it is#
# again a spatial distance matrix. However, two things make this more complex.#
# First distances between objects on the Earth's surface require a third#
# dimension to correctly account for the curvature of the Earth. This might not#
# be a huge problem at the scale of the UK, but will still exist. Second, and#
# more significantly these are road distances and roads are not laid out in#
# perfect straight lines or Great Circles. Thus we should expect that patter#
# we see, of more than two axes of notable variation. Nevertheless, we can see#
# that the vast majority of variance is contained on the first axis and more#
# generally that we can probably ignore the third axis onwards. We can thus#
# plot the data to explore what the major axis might represent with:#
plot(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  labels = rownames(UKCityDistanceOrdination), srt = -45)#
#
# Note that the data are plotted with a 1:1 aspect ratior (asp = 1) so you can#
# clearly tell how the variance compares between the two axes. Using your#
# knowledge of UK geography what can you say about the major axis of variance#
# (i.e., the x-axis or PC1)? What about the second axis (y-axis or PC2)? What#
# else strikes you about the plot?#
##
# So far we have looked at two data sets we already have a pre-concieved notion#
# of where our objects sit in space relative to each other. Now let's look at a#
# case where we do not to see if we can begin to understand how a novel space#
# might be constructed. Specifically, we are going to generate a "flagspace"#
# using the flags of France, Germany, India, Ireland, Italy, the Netherlands,#
# Japan, and the United Kingdom as examples. Below I have come up with 13#
# differences between these flags that can be coded numerically. These represent#
# 13 different axes of variation - exactly the kind of data set we might want#
# to reduce the dimensions of to better understand:#
CentralSymbol <-        c(0, 0, 1, 0, 0, 0, 1, 0)#
CrossSymbol <-          c(0, 0, 0, 0, 0, 0, 0, 1)#
HasBlack <-             c(0, 0, 1, 0, 0, 0, 0, 0)#
HasBlue <-              c(1, 1, 0, 0, 0, 1, 0, 1)#
HasGreen <-             c(0, 0, 1, 1, 1, 0, 0, 0)#
HasOrange <-            c(0, 0, 1, 1, 0, 0, 0, 0)#
HasRed <-               c(1, 1, 0, 0, 1, 1, 1, 1)#
HasWhite <-             c(1, 0, 1, 1, 1, 1, 1, 1)#
HasYellow <-            c(0, 1, 0, 0, 0, 0, 0, 0)#
SaltireSymbol <-        c(0, 0, 0, 0, 0, 0, 0, 1)#
ThreeHorizontalBands <- c(0, 1, 1, 0, 0, 1, 0, 0)#
ThreeVerticalBands <-   c(1, 0, 0, 1, 1, 0, 0, 0)#
TotalNColours <-        c(3, 3, 4, 3, 3, 3, 2, 3)#
#
# These can be combined into a single large data matrix with:#
FlagData <- t(matrix(c(CentralSymbol, CrossSymbol, HasBlack, HasBlue,#
  HasGreen, HasOrange, HasRed, HasWhite, HasYellow, SaltireSymbol,#
  ThreeHorizontalBands, ThreeVerticalBands, TotalNColours), ncol = 8,#
  byrow = TRUE, dimnames = list(c("CentralSymbol", "CrossSymbol", "HasBlack",#
  "HasBlue", "HasGreen", "HasOrange", "HasRed", "HasWhite", "HasYellow",#
  "SaltireSymbol", "ThreeHorizontalBands", "ThreeVerticalBands",#
  "TotalNColours"), c("France", "Germany", "India", "Ireland", "Italy",#
  "Netherlands", "Japan", "United Kingdom"))))#
FlagData#
#
# First we can convert all of this data down into a single distance matrix#
# with:#
FlagDistances <- dist(x = FlagData)#
FlagDistances#
#
# Note that underneath this is just the Pythagorean Theorem we discussed in#
# lecture. Now we can ordinate the data with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)#
#
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")#
#
# This time we can see the attempt to reduce the dimensionality of the data#
# was less successful as we can see notable variance across a much larger#
# number of axes. We can, however, force CMDS to place of the variance on just#
# two axes with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 2)#
#
# Note this isn't generally recommended as this will tend to distort the#
# distances between the objects we are interested in, but we can still use this#
# data to explore what the major axes of variation might represent. We can thus#
# plot the data with:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  labels = rownames(FlagData), srt = -45)#
#
# Unfortuantely it is not easy to understand this data by just looking at the#
# names of the countries. Instead it would help to visually see each flag in#
# the space. This requires writing a new (and long) function. Copy and paste#
# the following into R so we can start to plot the data more usefully.#
FlagPlotter <- function(Country = "Italy", XLimits = c(0, 1.5),#
  YLimits = c(0, 1)) {#
  # Set defaults:#
  Background <- LeftBand <- CentreBand <- RightBand <- TopBand <- MiddleBand <- BottomBand <- CentreCircle <- CentreWheel <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- FALSE#
  # If plotting France:#
  if(Country == "France") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "blue"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Germany:#
  if(Country == "Germany") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "black"#
    MiddleBandColour <- "red"#
    BottomBandColour <- "yellow"#
  }#
  # If plotting India:#
  if(Country == "India") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- CentreWheel <- TRUE#
    # Set band colours:#
    TopBandColour <- "orange"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "green"#
  }#
  # If plotting Ireland:#
  if(Country == "Ireland") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "orange"#
  }#
#
  # If plotting Italy:#
  if(Country == "Italy") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Japan:#
  if(Country == "Japan") {#
    # Turn on background and central cricle:#
    Background <- CentreCircle <- TRUE#
    # Set background and circle colours:#
    BackgroundColour <- "white"#
    CentreCircleColour <- "red"#
  }#
#
  # If plotting Netherlands:#
  if(Country == "Netherlands") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "red"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "blue"#
  }#
  # If plotting United Kingdoms:#
  if(Country == "United Kingdom") {#
    # Turn on background, cross, and saltire:#
    Background <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- TRUE#
    # Set background, cross, and saltire colours:#
    BackgroundColour <- "blue"#
    ThickCrossColour <- "white"#
    ThinCrossColour <- "red"#
    ThickSaltireColour <- "white"#
    ThinSaltireColour <- "red"#
  }#
#
  # If using background plot with chosen colour:#
  if(Background) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = BackgroundColour, border = 0)#
  # If using left band plot with chosen colour:#
  if(LeftBand) polygon(x = c(XLimits[1], XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = LeftBandColour, border = 0)#
  # If using centre band plot with chosen colour:#
  if(CentreBand) polygon(x = c(XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = CentreBandColour, border = 0)#
  # If using right band plot with chosen colour:#
  if(RightBand) polygon(x = c(XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = RightBandColour, border = 0)#
  # If using top band plot with chosen colour:#
  if(TopBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2], YLimits[2], YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits)))), col = TopBandColour, border = 0)#
  # If using middle band plot with chosen colour:#
  if(MiddleBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits)))), col = MiddleBandColour, border = 0)#
  # If using bottom band plot with chosen colour:#
  if(BottomBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits)))), col = BottomBandColour, border = 0)#
  # If using centre wheel plot with set colour:#
  if(CentreWheel) {#
    # Set wheel radius:#
    radius <- abs(diff(YLimits)) * (1 / 9)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot wheel:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), border = "blue")#
  }#
  # If using centre circle plot with chosen colour:#
  if(CentreCircle) {#
    # Set circle radius:#
    radius <- abs(diff(YLimits)) * (5 / 18)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot circle:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), col = CentreCircleColour, border = 0)#
  }#
  # If using thick saltire plot with chosen colour:#
  if(ThickSaltire) {#
    # Plot#
    polygon(x = c(XLimits[1], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((5 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThickSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((5 / 60) * abs(diff(YLimits)))), col = ThickSaltireColour, border = 0)#
  }#
  # If using thin saltire plot with chosen colour:#
  if(ThinSaltire) {#
    polygon(x = c(XLimits[1], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((3 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThinSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((3 / 60) * abs(diff(YLimits)))), col = ThinSaltireColour, border = 0)#
  }#
  # If using thick cross plot with chosen colour:#
  if(ThickCross) {#
    polygon(x = c(XLimits[1] + ((25 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((25 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThickCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits)))), col = ThickCrossColour, border = 0)#
  }#
  # If using thin cross plot with chosen colour:#
  if(ThinCross) {#
    polygon(x = c(XLimits[1] + ((27 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((27 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThinCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits)))), col = ThinCrossColour, border = 0)#
  }#
#
  # Add black border to flag:#
  polygon(x = XLimits[c(1, 2, 2, 1)], y = YLimits[c(1, 1, 2, 2)], col = rgb(1, 1, 1, 0), border = "black")#
}
FlagPlotter <- function(Country = "Italy", XLimits = c(0, 1.5),#
  YLimits = c(0, 1)) {#
  # Set defaults:#
  Background <- LeftBand <- CentreBand <- RightBand <- TopBand <- MiddleBand <- BottomBand <- CentreCircle <- CentreWheel <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- FALSE#
  # If plotting France:#
  if(Country == "France") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "blue"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Germany:#
  if(Country == "Germany") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "black"#
    MiddleBandColour <- "red"#
    BottomBandColour <- "yellow"#
  }#
  # If plotting India:#
  if(Country == "India") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- CentreWheel <- TRUE#
    # Set band colours:#
    TopBandColour <- "orange"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "green"#
  }#
  # If plotting Ireland:#
  if(Country == "Ireland") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "orange"#
  }#
#
  # If plotting Italy:#
  if(Country == "Italy") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Japan:#
  if(Country == "Japan") {#
    # Turn on background and central cricle:#
    Background <- CentreCircle <- TRUE#
    # Set background and circle colours:#
    BackgroundColour <- "white"#
    CentreCircleColour <- "red"#
  }#
#
  # If plotting Netherlands:#
  if(Country == "Netherlands") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "red"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "blue"#
  }#
  # If plotting United Kingdoms:#
  if(Country == "United Kingdom") {#
    # Turn on background, cross, and saltire:#
    Background <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- TRUE#
    # Set background, cross, and saltire colours:#
    BackgroundColour <- "blue"#
    ThickCrossColour <- "white"#
    ThinCrossColour <- "red"#
    ThickSaltireColour <- "white"#
    ThinSaltireColour <- "red"#
  }#
#
  # If using background plot with chosen colour:#
  if(Background) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = BackgroundColour, border = 0)#
  # If using left band plot with chosen colour:#
  if(LeftBand) polygon(x = c(XLimits[1], XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = LeftBandColour, border = 0)#
  # If using centre band plot with chosen colour:#
  if(CentreBand) polygon(x = c(XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = CentreBandColour, border = 0)#
  # If using right band plot with chosen colour:#
  if(RightBand) polygon(x = c(XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = RightBandColour, border = 0)#
  # If using top band plot with chosen colour:#
  if(TopBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2], YLimits[2], YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits)))), col = TopBandColour, border = 0)#
  # If using middle band plot with chosen colour:#
  if(MiddleBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits)))), col = MiddleBandColour, border = 0)#
  # If using bottom band plot with chosen colour:#
  if(BottomBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits)))), col = BottomBandColour, border = 0)#
  # If using centre wheel plot with set colour:#
  if(CentreWheel) {#
    # Set wheel radius:#
    radius <- abs(diff(YLimits)) * (1 / 9)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot wheel:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), border = "blue")#
  }#
  # If using centre circle plot with chosen colour:#
  if(CentreCircle) {#
    # Set circle radius:#
    radius <- abs(diff(YLimits)) * (5 / 18)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot circle:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), col = CentreCircleColour, border = 0)#
  }#
  # If using thick saltire plot with chosen colour:#
  if(ThickSaltire) {#
    # Plot#
    polygon(x = c(XLimits[1], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((5 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThickSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((5 / 60) * abs(diff(YLimits)))), col = ThickSaltireColour, border = 0)#
  }#
  # If using thin saltire plot with chosen colour:#
  if(ThinSaltire) {#
    polygon(x = c(XLimits[1], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((3 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThinSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((3 / 60) * abs(diff(YLimits)))), col = ThinSaltireColour, border = 0)#
  }#
  # If using thick cross plot with chosen colour:#
  if(ThickCross) {#
    polygon(x = c(XLimits[1] + ((25 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((25 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThickCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits)))), col = ThickCrossColour, border = 0)#
  }#
  # If using thin cross plot with chosen colour:#
  if(ThinCross) {#
    polygon(x = c(XLimits[1] + ((27 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((27 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThinCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits)))), col = ThinCrossColour, border = 0)#
  }#
#
  # Add black border to flag:#
  polygon(x = XLimits[c(1, 2, 2, 1)], y = YLimits[c(1, 1, 2, 2)], col = rgb(1, 1, 1, 0), border = "black")#
}#
#
# Next we will need to set the plotting size (height and width) for each flag:#
FlagWidth <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15)#
FlagHeight <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15) * (2 / 3)#
#
# Now we are ready to plot the data:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
FlagPlotter(Country = "France", XLimits = c(FlagPrincipalCoordinates["France",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["France", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["France", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["France", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "India", XLimits = c(FlagPrincipalCoordinates["India",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["India", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["India", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["India", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Ireland", XLimits = c(FlagPrincipalCoordinates["Ireland",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Ireland", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Ireland", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Ireland", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Italy", XLimits = c(FlagPrincipalCoordinates["Italy",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Italy", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Italy", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Italy", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Germany", XLimits = c(FlagPrincipalCoordinates["Germany",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Germany", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Germany", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Germany", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Japan", XLimits = c(FlagPrincipalCoordinates["Japan",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Japan", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Japan", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Japan", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Netherlands", XLimits =#
  c(FlagPrincipalCoordinates["Netherlands", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["Netherlands", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["Netherlands", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["Netherlands", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "United Kingdom", XLimits =#
  c(FlagPrincipalCoordinates["United Kingdom", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["United Kingdom", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["United Kingdom", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["United Kingdom", 2] + ((1 / 2) *#
  FlagHeight)))
browseURL("http://whiskyanalysis.com/index.php/background/early-attempts-at-flavour-classification/")#
#
# Or "musicspace" here (worth trying with headphones to see if you can hear#
# what the major axes represent):#
browseURL("http://everynoise.com/engenremap.html")#
#
# In lecture we also discussed how some of the properties of ordination spaces#
# can be co-opted to understand spherical data, i.e., the kinds of things we#
# as geologists might plot on stereonets. Specifically, we will look here at#
# another set of fold axis measurements (azimuths and plunges):#
FoldAxisData <- matrix(c(7, 24, 348, 36, 321, 18, 302, 8, 278, 14, 302, 16,#
  308, 2, 120, 4, 293, 13, 291, 14, 288, 10, 287, 10, 298, 16, 285, 10, 301,#
  14, 293, 14, 35, 18, 77, 28, 288, 17, 318, 18, 322, 24, 312, 24, 312, 16,#
  355, 18, 308, 24, 317, 32, 317, 17, 312, 17, 317, 14, 314, 14, 315, 18, 322,#
  25), ncol = 2, byrow = TRUE, dimnames = list(c(), c("Azimuth", "Plunge")))#
FoldAxisData
FoldAxisData <- matrix(c(7, 24, 348, 36, 321, 18, 302, 8, 278, 14, 302, 16,#
  308, 2, 120, 4, 293, 13, 291, 14, 288, 10, 287, 10, 298, 16, 285, 10, 301,#
  14, 293, 14, 35, 18, 77, 28, 288, 17, 318, 18, 322, 24, 312, 24, 312, 16,#
  355, 18, 308, 24, 317, 32, 317, 17, 312, 17, 317, 14, 314, 14, 315, 18, 322,#
  25), ncol = 2, byrow = TRUE, dimnames = list(c(), c("Azimuth", "Plunge")))#
FoldAxisData#
#
# Firstly we can plot this data using the "RFOC" package with:#
net()#
qpoint(az = FoldAxisData[, "Azimuth"], iang = 90 - FoldAxisData[, "Plunge"],#
  pch = 20, cex = 3, col = "red")
?qpoint
net()#
qpoint(az = FoldAxisData[, "Azimuth"], iang = 90 - FoldAxisData[, "Plunge"],#
  pch = 20, cex = 3, col = "red")
Point <- (S1 * S2) / nrow(FoldAxisData)#
Girdle <- (3 * S2 * S3) / nrow(FoldAxisData)#
Random <- (3 * S3) / nrow(FoldAxisData)#
#
# Then we can plot the data using the functions from the Ternary package with:#
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
Point <- (Lambda1 * Lambda2) / nrow(FoldAxisData)#
Girdle <- (3 * Lambda2 * Lambda3) / nrow(FoldAxisData)#
Random <- (3 * Lambda3) / nrow(FoldAxisData)#
#
# Then we can plot the data using the functions from the Ternary package with:#
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
Lambda1 <- 0.84#
Lambda2 <- 0.15#
Lambda3 <- 0.01#
#
# Note that these eignevalues correspond to each ordination axis in order and#
# thus must always be in ranked order from highest to lowest. Based on the#
# relationships between lambda 1-3 from lecture do you think the data best#
# conform to random, clustered, great circle, or scattered on a great circle,#
# but with a preferred direction? Does this match up ith your visual#
# inspection? Next we will generate the ternary diagram from lecture that is#
# intended to help us make this decision. First we need to perfofm the#
# necessary point, girdle, and random calculations from lecture:#
Point <- (Lambda1 * Lambda2) / nrow(FoldAxisData)#
Girdle <- (3 * Lambda2 * Lambda3) / nrow(FoldAxisData)#
Random <- (3 * Lambda3) / nrow(FoldAxisData)#
#
# Then we can plot the data using the functions from the Ternary package with:#
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
Lambda1 <- 0.84#
Lambda2 <- 0.15#
Lambda3 <- 0.01#
Lambda1#
Lambda2#
Lambda3
Lambda1 <- 0.84#
Lambda2 <- 0.15#
Lambda3 <- 0.01#
Lambda1#
Lambda2#
Lambda3#
#
# Note that these eignevalues correspond to each ordination axis in order and#
# thus must always be in ranked order from highest to lowest. Based on the#
# relationships between lambda 1-3 from lecture do you think the data best#
# conform to random, clustered, great circle, or scattered on a great circle,#
# but with a preferred direction? Does this match up ith your visual#
# inspection? Next we will generate the ternary diagram from lecture that is#
# intended to help us make this decision. First we need to perfofm the#
# necessary point, girdle, and random calculations from lecture:#
Point <- (Lambda1 * Lambda2) / nrow(FoldAxisData)#
Girdle <- (3 * Lambda2 * Lambda3) / nrow(FoldAxisData)#
Random <- (3 * Lambda3) / nrow(FoldAxisData)#
#
# Then we can plot the data using the functions from the Ternary package with:#
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
Point <- (Lambda1 * Lambda2) / nrow(FoldAxisData)#
Girdle <- (3 * Lambda2 * Lambda3) / nrow(FoldAxisData)#
Random <- (3 * Lambda3) / nrow(FoldAxisData)#
#
# Then we can plot the data using the functions from the Ternary package with:#
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
X <- log(S2 / S3)#
Y <- log(S1 / S2)#
#
# Next we can plot the data (with additional C and K axes plotted into the same#
# bivariate space:#
par(mar = c(5, 5, 6, 6))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l",#
  xlab = expression(ln(lambda[2] / lambda[3])),#
  ylab = expression(ln(lambda[1] / lambda[2])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2,#
  lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5),#
  col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i),#
  col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5),#
  y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i),#
  col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
X <- log(Lambda2 / Lambda3)#
Y <- log(Lambda1 / Lambda2)#
#
# Next we can plot the data (with additional C and K axes plotted into the same#
# bivariate space:#
par(mar = c(5, 5, 6, 6))#
plot(x = X, y = Y, type = "n", xlim = c(0, 5), ylim = c(0, 5), bty = "l",#
  xlab = expression(ln(lambda[2] / lambda[3])),#
  ylab = expression(ln(lambda[1] / lambda[2])))#
for(i in 1:4 * 2) lines(x = c(0, i), y = c(i, 0), col = "blue", lty = 2,#
  lwd = 2)#
for(i in c(0.2, 0.5, 1, 2, 5)) lines(x = c(0, 5), y = c(0, i * 5),#
  col = "blue", lty = 2, lwd = 2)#
for(i in 1:4 * 2) text(x = i / 2, y = i / 2, labels = paste("C =", i),#
  col = "blue", cex = 1.5)#
for(i in c(0.2, 0.5, 1, 2, 5)) text(x = ifelse(i * 5 > 5, 5, i * 5),#
  y = ifelse((1 / i) * 5 > 5, 5, (1 / i) * 5), labels = paste("K =", i),#
  col = "blue", cex = 1.5, adj = c(1, 0))#
mtext(text = "Clusters", side = 3, col = "blue", cex = 1.5)#
mtext(text = "Girdles", side = 4, col = "blue", cex = 1.5)#
points(x = X, y = Y, pch = 20, col = "red", cex = 2)#
par(mar = c(5, 4, 4, 2) + 0.1)
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)#
#
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance",#
  space = 0, border = 0, names.arg = 1:ncol(UKCityDistanceOrdination),#
  xlab = "Ordination axes")
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 2)#
#
# Note this isn't generally recommended as this will tend to distort the#
# distances between the objects we are interested in, but we can still use this#
# data to explore what the major axes of variation might represent. We can thus#
# plot the data with:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  labels = rownames(FlagData), srt = -45)#
#
# Unfortuantely it is not easy to understand this data by just looking at the#
# names of the countries. Instead it would help to visually see each flag in#
# the space. This requires writing a new (and long) function. Copy and paste#
# the following into R so we can start to plot the data more usefully.#
FlagPlotter <- function(Country = "Italy", XLimits = c(0, 1.5),#
  YLimits = c(0, 1)) {#
  # Set defaults:#
  Background <- LeftBand <- CentreBand <- RightBand <- TopBand <- MiddleBand <- BottomBand <- CentreCircle <- CentreWheel <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- FALSE#
  # If plotting France:#
  if(Country == "France") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "blue"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Germany:#
  if(Country == "Germany") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "black"#
    MiddleBandColour <- "red"#
    BottomBandColour <- "yellow"#
  }#
  # If plotting India:#
  if(Country == "India") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- CentreWheel <- TRUE#
    # Set band colours:#
    TopBandColour <- "orange"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "green"#
  }#
  # If plotting Ireland:#
  if(Country == "Ireland") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "orange"#
  }#
#
  # If plotting Italy:#
  if(Country == "Italy") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Japan:#
  if(Country == "Japan") {#
    # Turn on background and central cricle:#
    Background <- CentreCircle <- TRUE#
    # Set background and circle colours:#
    BackgroundColour <- "white"#
    CentreCircleColour <- "red"#
  }#
#
  # If plotting Netherlands:#
  if(Country == "Netherlands") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "red"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "blue"#
  }#
  # If plotting United Kingdoms:#
  if(Country == "United Kingdom") {#
    # Turn on background, cross, and saltire:#
    Background <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- TRUE#
    # Set background, cross, and saltire colours:#
    BackgroundColour <- "blue"#
    ThickCrossColour <- "white"#
    ThinCrossColour <- "red"#
    ThickSaltireColour <- "white"#
    ThinSaltireColour <- "red"#
  }#
#
  # If using background plot with chosen colour:#
  if(Background) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = BackgroundColour, border = 0)#
  # If using left band plot with chosen colour:#
  if(LeftBand) polygon(x = c(XLimits[1], XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = LeftBandColour, border = 0)#
  # If using centre band plot with chosen colour:#
  if(CentreBand) polygon(x = c(XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = CentreBandColour, border = 0)#
  # If using right band plot with chosen colour:#
  if(RightBand) polygon(x = c(XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = RightBandColour, border = 0)#
  # If using top band plot with chosen colour:#
  if(TopBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2], YLimits[2], YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits)))), col = TopBandColour, border = 0)#
  # If using middle band plot with chosen colour:#
  if(MiddleBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits)))), col = MiddleBandColour, border = 0)#
  # If using bottom band plot with chosen colour:#
  if(BottomBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits)))), col = BottomBandColour, border = 0)#
  # If using centre wheel plot with set colour:#
  if(CentreWheel) {#
    # Set wheel radius:#
    radius <- abs(diff(YLimits)) * (1 / 9)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot wheel:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), border = "blue")#
  }#
  # If using centre circle plot with chosen colour:#
  if(CentreCircle) {#
    # Set circle radius:#
    radius <- abs(diff(YLimits)) * (5 / 18)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot circle:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), col = CentreCircleColour, border = 0)#
  }#
  # If using thick saltire plot with chosen colour:#
  if(ThickSaltire) {#
    # Plot#
    polygon(x = c(XLimits[1], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((5 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThickSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((5 / 60) * abs(diff(YLimits)))), col = ThickSaltireColour, border = 0)#
  }#
  # If using thin saltire plot with chosen colour:#
  if(ThinSaltire) {#
    polygon(x = c(XLimits[1], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((3 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThinSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((3 / 60) * abs(diff(YLimits)))), col = ThinSaltireColour, border = 0)#
  }#
  # If using thick cross plot with chosen colour:#
  if(ThickCross) {#
    polygon(x = c(XLimits[1] + ((25 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((25 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThickCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits)))), col = ThickCrossColour, border = 0)#
  }#
  # If using thin cross plot with chosen colour:#
  if(ThinCross) {#
    polygon(x = c(XLimits[1] + ((27 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((27 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThinCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits)))), col = ThinCrossColour, border = 0)#
  }#
#
  # Add black border to flag:#
  polygon(x = XLimits[c(1, 2, 2, 1)], y = YLimits[c(1, 1, 2, 2)], col = rgb(1, 1, 1, 0), border = "black")#
}#
#
# Next we will need to set the plotting size (height and width) for each flag:#
FlagWidth <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15)#
FlagHeight <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15) * (2 / 3)#
#
# Now we are ready to plot the data:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
FlagPlotter(Country = "France", XLimits = c(FlagPrincipalCoordinates["France",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["France", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["France", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["France", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "India", XLimits = c(FlagPrincipalCoordinates["India",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["India", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["India", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["India", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Ireland", XLimits = c(FlagPrincipalCoordinates["Ireland",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Ireland", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Ireland", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Ireland", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Italy", XLimits = c(FlagPrincipalCoordinates["Italy",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Italy", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Italy", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Italy", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Germany", XLimits = c(FlagPrincipalCoordinates["Germany",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Germany", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Germany", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Germany", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Japan", XLimits = c(FlagPrincipalCoordinates["Japan",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Japan", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Japan", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Japan", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Netherlands", XLimits =#
  c(FlagPrincipalCoordinates["Netherlands", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["Netherlands", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["Netherlands", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["Netherlands", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "United Kingdom", XLimits =#
  c(FlagPrincipalCoordinates["United Kingdom", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["United Kingdom", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["United Kingdom", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["United Kingdom", 2] + ((1 / 2) *#
  FlagHeight)))
TernaryPlot(atip = "Random", btip = "Point", ctip = "Girdle",#
  alab = expression(lambda[1] == lambda[2]),#
  blab = expression(lambda[2] == lambda[3]),#
  clab = expression(lambda[3] == '0'), point = "down", axis.labels = FALSE)#
AddToTernary(PlottingFunction = points,#
  coordinates = list(c(Random, Point, Girdle)), col = "red", pch = 20,#
  cex = 2)
plot(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  labels = rownames(UKCityDistanceOrdination), srt = -45)
FlagDistances
√
net()#
qpoint(az = FoldAxisData[, "Azimuth"], iang = 90 - FoldAxisData[, "Plunge"],#
  pch = 20, cex = 3, col = "red")
log(1)
#################################################################################
#                                                                              ##
#                    PRACTICAL IX - MULTIVARIATE STATISTICS                    ##
#                                                                              ##
#################################################################################
#
#################################################################################
#                                                                              ##
#                               TODAY'S AIMS                                   ##
#                                                                              ##
# - LEARN HOW TO PERFORM A SIMPLE BIVARIATE ORDINATION IN R AND INTERPRET THE  ##
#   SPACE (DISTRIBUTION OF VARIANCE ACROSS AXES AND MEANING OF MAJOR AXES OF   ##
#   VARIANCE)                                                                  ##
# - LEARN HOW TO PERFORM MORE COMPLEX MULTIVARIATE ORDINATIONS IN R AND        ##
#   INTERPRET THE RESULTING SPACE                                              ##
# - LEARN HOW TO APPLY MULTIVARIATE METHODOLOGIES TO SPHERICAL DATA AND PLOT   ##
#   STEREONETS AND TERNARY DIAGRAMS IN R                                       ##
#                                                                              ##
#################################################################################
#
# Before we start begin by setting your working directory.#
#
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "X4"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath#
#
# You can read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues#
#
# These are the ammonites (numbered 1-20), their X and Y coordinates (in#
# millimetres from an origin at the bottom left of the quadrat), their#
# diameters (in millimetres), the number of chambers, and the bearing of their#
# apertures (in degrees). Compare these to your own measurements. You should#
# hopefully find they are very similar. However, you may have found that you#
# were unable to replicate the precision of these values. Don't worry about#
# this as you were working with a smaller scale version and should still have#
# got the right overall answers we discussed in lecture.#
##
# Before we leave ammonites behind for good we can use their xy coordinates to#
# illustrate one form of multivariate analysis known as "Classic Multi-#
# Dimensional Scaling" (CMDS), sometimes also called "Principal Coordinates".#
# This works by accepting a distance matrix - a matrix where the rows and#
# columns represent the same set of objects and the values the distances#
# between them - and turning this into a set of coordinates for those objects.#
# This can be used to do multivariate analysis as those distances can come from#
# as many variables as desired. However, here we are just going to use two -#
# our x and y axes. Note that this is not something we should do with this#
# data, this is simply a way to illustrate the process. We can generate the#
# distance matrix with:#
AmmoniteDistanceMatrix <- dist(AmmoniteQuadratValues[,#
  c("X_coordinate", "Y_coordinate")])#
AmmoniteDistanceMatrix#
#
# Next we can ordinate the data with:#
AmmoniteOrdination <- cmdscale(d = AmmoniteDistanceMatrix, k = 19)#
#
# Here we provide the function with the distance matrix (d) and set the number#
# of axes we will allow the variance to be spread over (k). Here we are#
# allowing the maximum possible (which is N - 1, for N total objects), i.e.,#
# 20 ammonites - 1 = 19. You should see, however, that many of these axes are#
# immediately discarded as their effective variance is zero (i.e., the warning#
# message). You might be wondering why there are more than two axes at all as#
# we know the raw data only requires two axes to plot it. Well you can#
# visually compare the variance across each ordination axis with:#
barplot(apply(AmmoniteOrdination, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(AmmoniteOrdination), xlab = "Ordination axes")#
#
# What does this show you? Remember that each axis must always have LOWER#
# variance than the preceding one. You should see that from the third axis#
# onwards there is effectively no variance, i.e., the ordination has correctly#
# identified that only two axes are really needed to explain the data. You can#
# plot these with:#
plot(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], xlab = "PC1",#
  ylab = "PC2", type = "n", asp = 1)#
text(x = AmmoniteOrdination[, 1], y = AmmoniteOrdination[, 2], labels = 1:20)#
#
# What can you see when you look at this plot? Hint: try comparing it to the#
# raw data with (paying attention to the ammonite numbers):#
browseURL(paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/", QuadratNumber, ".pdf", sep = ""))#
#
# You should see that there is not a substantial reduction in dimensionality,#
# but the data do not really allow this as the spread of data is roughly#
# equal in all directions - i.e., consistent with the spatial pattern of a#
# uniform distribution we found previously. The other thing you should notice#
# is there is likely some rotation of the data and possibly even a reflection.#
# Remember a rotation is a typical part of the ordination process. If you look#
# at the axis values you should also see some negative values and generally#
# that the new origin (0, 0) sits directly in the centre of the data. Again,#
# what we would expect from an ordination. Now let's look at a similar type of#
# data set, the distance in miles (by road) between several major UK cities:#
UKCityDistances <- matrix(c(0, 239, 53, 252, 174, 80, 181, 82, 65, 194, 97, 25,#
  344, 210, 292, 186, 264, 88, 231, 217, 129, 195, 307, 239, 0, 195, 17, 65,#
  160, 190, 319, 208, 77, 217, 229, 575, 419, 107, 418, 143, 154, 118, 74, 128,#
  198, 538, 53, 95, 0, 208, 130, 38, 146, 128, 38, 160, 72, 34, 385, 241,#
  240, 227, 229, 37, 178, 164, 76, 156, 347, 252, 17, 208, 0, 78, 173, 184,#
  332, 222, 71, 231, 242, 589, 432, 124, 431, 131, 175, 138, 94, 141, 218,#
  552, 174, 65, 130, 78, 0, 95, 141, 254, 144, 56, 153, 164, 511, 354, 141,#
  353, 129, 90, 104, 70, 63, 157, 473, 80, 160, 38, 173, 95, 0, 123, 159, 71,#
  123, 99, 70, 416, 279, 213, 259, 196, 16, 151, 137, 49, 156, 379, 181, 190,#
  146, 184, 141, 123, 0, 260, 185, 112, 217, 174, 517, 383, 282, 360, 156,#
  139, 235, 209, 161, 271, 480, 82, 319, 128, 332, 254, 159, 260, 0, 131,#
  274, 155, 94, 265, 145, 364, 107, 343, 161, 301, 288, 204, 259, 228, 65,#
  208, 38, 222, 144, 71, 185, 131, 0, 184, 34, 41, 371, 214, 238, 213, 257,#
  59, 173, 162, 81, 131, 333, 194, 77, 160, 71, 56, 123, 112, 274, 184, 0,#
  198, 191, 529, 389, 170, 372, 74, 123, 150, 114, 111, 212, 492, 97, 217,#
  72, 231, 153, 99, 217, 155, 34, 198, 0, 73, 372, 216, 237, 214, 270, 81,#
  165, 161, 90, 105, 335, 25, 229, 34, 242, 164, 70, 174, 94, 41, 191, 73, 0,#
  351, 211, 271, 193, 257, 70, 208, 196, 110, 171, 314, 344, 575, 385, 589,#
  511, 416, 517, 265, 371, 529, 372, 351, 0, 167, 602, 158, 600, 419, 530,#
  527, 448, 477, 107, 210, 419, 241, 432, 354, 279, 383, 145, 214, 389, 216,#
  211, 167, 0, 446, 45, 466, 270, 374, 371, 292, 321, 141, 292, 107, 240,#
  124, 141, 213, 282, 364, 238, 170, 237, 271, 602, 446, 0, 444, 244, 203,#
  120, 75, 164, 199, 565, 186, 418, 227, 431, 353, 259, 360, 107, 213, 372,#
  214, 193, 158, 45, 444, 0, 442, 263, 373, 369, 290, 320, 121, 264, 143,#
  229, 131, 129, 196, 156, 343, 257, 74, 270, 257, 600, 466, 244, 442, 0,#
  196, 228, 189, 185, 285, 563, 88, 154, 37, 175, 90, 16, 139, 161, 59, 123,#
  81, 70, 419, 270, 203, 263, 196, 0, 142, 127, 40, 140, 384, 231, 118, 178,#
  138, 104, 151, 235, 301, 173, 150, 165, 208, 530, 374, 120, 373, 228, 142,#
  0, 44, 102, 110, 493, 217, 74, 164, 94, 70, 137, 209, 288, 162, 114, 161,#
  196, 527, 371, 75, 369, 189, 127, 44, 0, 88, 124, 490, 129, 128, 76, 141,#
  63, 49, 161, 204, 81, 111, 90, 110, 448, 292, 164, 290, 185, 40, 102, 88,#
  0, 116, 411, 195, 198, 156, 218, 157, 156, 271, 259, 131, 212, 105, 171,#
  477, 321, 199, 320, 285, 140, 110, 124, 116, 0, 440, 307, 538, 347, 552,#
  473, 379, 480, 228, 333, 492, 335, 314, 107, 141, 565, 121, 563, 384, 493,#
  490, 411, 440, 0),  ncol = 23, dimnames = list(rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York")), rev(c("Aberdeen",#
  "Aberystwyth", "Birmingham", "Bristol", "Cardiff", "Derby", "Dover",#
  "Edinburgh", "Exeter", "Glasgow", "Inverness", "Leeds", "Liverpool",#
  "London", "Manchester", "Newcastle", "Norwich", "Nottingham", "Oxford",#
  "Portsmouth", "Sheffield", "Southampton", "York"))))#
UKCityDistances#
#
# We can ordinate this with CMDS again:#
UKCityDistanceOrdination <- cmdscale(UKCityDistances,#
  k = ncol(UKCityDistances) - 1)#
#
# You should see, again, that we do not need all the axes of variance we ask#
# for. Let's start by looking at variance across each axis again:#
barplot(apply(UKCityDistanceOrdination, 2, var), ylab = "Variance",#
  space = 0, border = 0, names.arg = 1:ncol(UKCityDistanceOrdination),#
  xlab = "Ordination axes")#
#
# We might assume, again, that we only really need two axes here as it is#
# again a spatial distance matrix. However, two aspects make this more complex.#
# First distances between objects on the Earth's surface require a third#
# dimension to correctly account for the curvature of the Earth. This might not#
# be a huge problem at the scale of the UK, but will still exist. Second, and#
# more significantly, these are road distances and roads are not laid out in#
# perfect straight lines or Great Circles. Thus we should expect the pattern#
# we see, of more than two axes of notable variation. Nevertheless, we can see#
# that the vast majority of variance is contained on the first axis and more#
# generally that we can probably ignore the third axis onwards. We can thus#
# plot the data to explore what the major axis might represent with:#
plot(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = UKCityDistanceOrdination[, 1], y = UKCityDistanceOrdination[, 2],#
  labels = rownames(UKCityDistanceOrdination), srt = -45)#
#
# Note that the data are plotted with a 1:1 aspect ratio (asp = 1) so you can#
# clearly tell how the variance compares between the two axes. Using your#
# knowledge of UK geography what can you say about the major axis of variance#
# (i.e., the x-axis or PC1)? What about the second axis (y-axis or PC2)? What#
# else strikes you about the plot?#
##
# So far we have looked at two data sets where we already have a pre-conceived#
# notion of where our objects sit relative to each other. Now let's look at a#
# case where we do not to see if we can begin to understand how a novel space#
# might be constructed. Specifically, we are going to generate a "flagspace"#
# using the flags of France, Germany, India, Ireland, Italy, the Netherlands,#
# Japan, and the United Kingdom as examples. Below I have come up with 13#
# differences between these flags that can be coded numerically. These represent#
# 13 different axes of variation - exactly the kind of data set we might want#
# to reduce the dimensions of to better understand:#
CentralSymbol <-        c(0, 0, 1, 0, 0, 0, 1, 0)#
CrossSymbol <-          c(0, 0, 0, 0, 0, 0, 0, 1)#
HasBlack <-             c(0, 0, 1, 0, 0, 0, 0, 0)#
HasBlue <-              c(1, 1, 0, 0, 0, 1, 0, 1)#
HasGreen <-             c(0, 0, 1, 1, 1, 0, 0, 0)#
HasOrange <-            c(0, 0, 1, 1, 0, 0, 0, 0)#
HasRed <-               c(1, 1, 0, 0, 1, 1, 1, 1)#
HasWhite <-             c(1, 0, 1, 1, 1, 1, 1, 1)#
HasYellow <-            c(0, 1, 0, 0, 0, 0, 0, 0)#
SaltireSymbol <-        c(0, 0, 0, 0, 0, 0, 0, 1)#
ThreeHorizontalBands <- c(0, 1, 1, 0, 0, 1, 0, 0)#
ThreeVerticalBands <-   c(1, 0, 0, 1, 1, 0, 0, 0)#
TotalNColours <-        c(3, 3, 4, 3, 3, 3, 2, 3)#
#
# These can be combined into a single large data matrix with:#
FlagData <- t(matrix(c(CentralSymbol, CrossSymbol, HasBlack, HasBlue,#
  HasGreen, HasOrange, HasRed, HasWhite, HasYellow, SaltireSymbol,#
  ThreeHorizontalBands, ThreeVerticalBands, TotalNColours), ncol = 8,#
  byrow = TRUE, dimnames = list(c("CentralSymbol", "CrossSymbol", "HasBlack",#
  "HasBlue", "HasGreen", "HasOrange", "HasRed", "HasWhite", "HasYellow",#
  "SaltireSymbol", "ThreeHorizontalBands", "ThreeVerticalBands",#
  "TotalNColours"), c("France", "Germany", "India", "Ireland", "Italy",#
  "Netherlands", "Japan", "United Kingdom"))))#
FlagData#
#
# First we can convert all of this data down into a single distance matrix#
# with:#
FlagDistances <- dist(x = FlagData)#
FlagDistances#
#
# Note that underneath this is just the Pythagorean Theorem we discussed in#
# lecture. Now we can ordinate the data with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 7)#
#
# And again, look at the distribution of variance with:#
barplot(apply(FlagPrincipalCoordinates, 2, var), ylab = "Variance", space = 0,#
  border = 0, names.arg = 1:ncol(FlagPrincipalCoordinates),#
  xlab = "Ordination axes")#
#
# This time we can see the attempt to reduce the dimensionality of the data#
# was less successful as we can see notable variance across a much larger#
# number of axes. We can, however, force CMDS to place the variance on just#
# two axes with:#
FlagPrincipalCoordinates <- cmdscale(FlagDistances, k = 2)#
#
# Note this isn't generally recommended as this will tend to distort the#
# distances between the objects we are interested in, but we can still use this#
# data to explore what the major axes of variation might represent. We can thus#
# plot the data with:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
text(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  labels = rownames(FlagData), srt = -45)#
#
# Unfortuantely it is not easy to understand this data by just looking at the#
# names of the countries. Instead it would help to visually see each flag in#
# the space. This requires writing a new (and long) function. Copy and paste#
# the following into R so we can start to plot the data more usefully.#
FlagPlotter <- function(Country = "Italy", XLimits = c(0, 1.5),#
  YLimits = c(0, 1)) {#
  # Set defaults:#
  Background <- LeftBand <- CentreBand <- RightBand <- TopBand <- MiddleBand <- BottomBand <- CentreCircle <- CentreWheel <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- FALSE#
  # If plotting France:#
  if(Country == "France") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "blue"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Germany:#
  if(Country == "Germany") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "black"#
    MiddleBandColour <- "red"#
    BottomBandColour <- "yellow"#
  }#
  # If plotting India:#
  if(Country == "India") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- CentreWheel <- TRUE#
    # Set band colours:#
    TopBandColour <- "orange"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "green"#
  }#
  # If plotting Ireland:#
  if(Country == "Ireland") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "orange"#
  }#
#
  # If plotting Italy:#
  if(Country == "Italy") {#
    # Turn on vertical bands:#
    LeftBand <- CentreBand <- RightBand <- TRUE#
    # Set band colours:#
    LeftBandColour <- "green"#
    CentreBandColour <- "white"#
    RightBandColour <- "red"#
  }#
  # If plotting Japan:#
  if(Country == "Japan") {#
    # Turn on background and central cricle:#
    Background <- CentreCircle <- TRUE#
    # Set background and circle colours:#
    BackgroundColour <- "white"#
    CentreCircleColour <- "red"#
  }#
#
  # If plotting Netherlands:#
  if(Country == "Netherlands") {#
    # Turn on horizontal bands:#
    TopBand <- MiddleBand <- BottomBand <- TRUE#
    # Set band colours:#
    TopBandColour <- "red"#
    MiddleBandColour <- "white"#
    BottomBandColour <- "blue"#
  }#
  # If plotting United Kingdoms:#
  if(Country == "United Kingdom") {#
    # Turn on background, cross, and saltire:#
    Background <- ThickCross <- ThinCross <- ThickSaltire <- ThinSaltire <- TRUE#
    # Set background, cross, and saltire colours:#
    BackgroundColour <- "blue"#
    ThickCrossColour <- "white"#
    ThinCrossColour <- "red"#
    ThickSaltireColour <- "white"#
    ThinSaltireColour <- "red"#
  }#
#
  # If using background plot with chosen colour:#
  if(Background) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = BackgroundColour, border = 0)#
  # If using left band plot with chosen colour:#
  if(LeftBand) polygon(x = c(XLimits[1], XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = LeftBandColour, border = 0)#
  # If using centre band plot with chosen colour:#
  if(CentreBand) polygon(x = c(XLimits[1] + ((1 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((1 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = CentreBandColour, border = 0)#
  # If using right band plot with chosen colour:#
  if(RightBand) polygon(x = c(XLimits[1] + ((2 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((3 / 3) * abs(diff(XLimits))), XLimits[1] + ((2 / 3) * abs(diff(XLimits)))), y = c(YLimits[1], YLimits[1], YLimits[2], YLimits[2]), col = RightBandColour, border = 0)#
  # If using top band plot with chosen colour:#
  if(TopBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2], YLimits[2], YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits)))), col = TopBandColour, border = 0)#
  # If using middle band plot with chosen colour:#
  if(MiddleBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((1 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits)))), col = MiddleBandColour, border = 0)#
  # If using bottom band plot with chosen colour:#
  if(BottomBand) polygon(x = c(XLimits[1], XLimits[2], XLimits[2], XLimits[1]), y = c(YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((2 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits))), YLimits[2] - ((3 / 3) * abs(diff(YLimits)))), col = BottomBandColour, border = 0)#
  # If using centre wheel plot with set colour:#
  if(CentreWheel) {#
    # Set wheel radius:#
    radius <- abs(diff(YLimits)) * (1 / 9)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot wheel:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), border = "blue")#
  }#
  # If using centre circle plot with chosen colour:#
  if(CentreCircle) {#
    # Set circle radius:#
    radius <- abs(diff(YLimits)) * (5 / 18)#
    # Set angles:#
    angles <- seq(0, 2 * pi - (2 * pi / 1000), by = 2 * pi / 1000)#
    # Plot circle:#
    polygon(x = cos(angles) * radius + mean(XLimits), y = sin(angles) * radius + mean(YLimits), col = CentreCircleColour, border = 0)#
  }#
  # If using thick saltire plot with chosen colour:#
  if(ThickSaltire) {#
    # Plot#
    polygon(x = c(XLimits[1], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((5 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThickSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((5 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((55 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((55 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((5 / 60) * abs(diff(YLimits)))), col = ThickSaltireColour, border = 0)#
  }#
  # If using thin saltire plot with chosen colour:#
  if(ThinSaltire) {#
    polygon(x = c(XLimits[1], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[1], YLimits[1], YLimits[1] + ((3 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2]), col = ThinSaltireColour, border = 0)#
    polygon(x = c(XLimits[1], XLimits[1] + ((3 / 60) * abs(diff(XLimits))), XLimits[2], XLimits[2], XLimits[1] + ((57 / 60) * abs(diff(XLimits))), XLimits[1]), y = c(YLimits[1], YLimits[1], YLimits[1] + ((57 / 60) * abs(diff(YLimits))), YLimits[2], YLimits[2], YLimits[1] + ((3 / 60) * abs(diff(YLimits)))), col = ThinSaltireColour, border = 0)#
  }#
  # If using thick cross plot with chosen colour:#
  if(ThickCross) {#
    polygon(x = c(XLimits[1] + ((25 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((35 / 60) * abs(diff(XLimits))), XLimits[1] + ((25 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThickCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((1 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits))), YLimits[1] + ((2 / 3) * abs(diff(YLimits)))), col = ThickCrossColour, border = 0)#
  }#
  # If using thin cross plot with chosen colour:#
  if(ThinCross) {#
    polygon(x = c(XLimits[1] + ((27 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((33 / 60) * abs(diff(XLimits))), XLimits[1] + ((27 / 60) * abs(diff(XLimits)))), y = YLimits[c(1, 1, 2, 2)], col = ThinCrossColour, border = 0)#
    polygon(x = XLimits[c(1, 2, 2, 1)], y = c(YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((12 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits))), YLimits[1] + ((18 / 30) * abs(diff(YLimits)))), col = ThinCrossColour, border = 0)#
  }#
#
  # Add black border to flag:#
  polygon(x = XLimits[c(1, 2, 2, 1)], y = YLimits[c(1, 1, 2, 2)], col = rgb(1, 1, 1, 0), border = "black")#
}#
#
# Next we will need to set the plotting size (height and width) for each flag:#
FlagWidth <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15)#
FlagHeight <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15) * (2 / 3)#
#
# Now we are ready to plot the data:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
FlagPlotter(Country = "France", XLimits = c(FlagPrincipalCoordinates["France",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["France", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["France", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["France", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "India", XLimits = c(FlagPrincipalCoordinates["India",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["India", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["India", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["India", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Ireland", XLimits = c(FlagPrincipalCoordinates["Ireland",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Ireland", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Ireland", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Ireland", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Italy", XLimits = c(FlagPrincipalCoordinates["Italy",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Italy", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Italy", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Italy", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Germany", XLimits = c(FlagPrincipalCoordinates["Germany",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Germany", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Germany", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Germany", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Japan", XLimits = c(FlagPrincipalCoordinates["Japan",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Japan", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Japan", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Japan", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Netherlands", XLimits =#
  c(FlagPrincipalCoordinates["Netherlands", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["Netherlands", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["Netherlands", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["Netherlands", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "United Kingdom", XLimits =#
  c(FlagPrincipalCoordinates["United Kingdom", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["United Kingdom", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["United Kingdom", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["United Kingdom", 2] + ((1 / 2) *#
  FlagHeight)))
# However, all yyou need to do is get it into memory with:#
source("http://www.graemetlloyd.com/teaching/SOEE1470/18/StatsFunctions.r")#
#
# Next we will need to set the plotting size (height and width) for each flag:#
FlagWidth <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15)#
FlagHeight <- diff(range(FlagPrincipalCoordinates[, 1])) * (1 / 15) * (2 / 3)#
#
# Now we are ready to plot the data:#
plot(x = FlagPrincipalCoordinates[, 1], y = FlagPrincipalCoordinates[, 2],#
  type = "n", asp = 1, xlab = "PC1", ylab = "PC2")#
FlagPlotter(Country = "France", XLimits = c(FlagPrincipalCoordinates["France",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["France", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["France", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["France", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "India", XLimits = c(FlagPrincipalCoordinates["India",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["India", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["India", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["India", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Ireland", XLimits = c(FlagPrincipalCoordinates["Ireland",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Ireland", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Ireland", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Ireland", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Italy", XLimits = c(FlagPrincipalCoordinates["Italy",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Italy", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Italy", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Italy", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Germany", XLimits = c(FlagPrincipalCoordinates["Germany",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Germany", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Germany", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Germany", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Japan", XLimits = c(FlagPrincipalCoordinates["Japan",#
  1] - ((1 / 2) * FlagWidth), FlagPrincipalCoordinates["Japan", 1] + ((1 / 2)#
  * FlagWidth)), YLimits = c(FlagPrincipalCoordinates["Japan", 2] - ((1 / 2)#
  * FlagHeight), FlagPrincipalCoordinates["Japan", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "Netherlands", XLimits =#
  c(FlagPrincipalCoordinates["Netherlands", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["Netherlands", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["Netherlands", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["Netherlands", 2] + ((1 / 2) *#
  FlagHeight)))#
FlagPlotter(Country = "United Kingdom", XLimits =#
  c(FlagPrincipalCoordinates["United Kingdom", 1] - ((1 / 2) * FlagWidth),#
  FlagPrincipalCoordinates["United Kingdom", 1] + ((1 / 2) * FlagWidth)),#
  YLimits = c(FlagPrincipalCoordinates["United Kingdom", 2] - ((1 / 2) *#
  FlagHeight), FlagPrincipalCoordinates["United Kingdom", 2] + ((1 / 2) *#
  FlagHeight)))
#################################################################################
#                                                                              ##
#                    PRACTICAL IX - MULTIVARIATE STATISTICS                    ##
#                                                                              ##
#################################################################################
#
#################################################################################
#                                                                              ##
#                               TODAY'S AIMS                                   ##
#                                                                              ##
# - LEARN HOW TO PERFORM A SIMPLE BIVARIATE ORDINATION IN R AND INTERPRET THE  ##
#   SPACE (DISTRIBUTION OF VARIANCE ACROSS AXES AND MEANING OF MAJOR AXES OF   ##
#   VARIANCE)                                                                  ##
# - LEARN HOW TO PERFORM MORE COMPLEX MULTIVARIATE ORDINATIONS IN R AND        ##
#   INTERPRET THE RESULTING SPACE                                              ##
# - LEARN HOW TO APPLY MULTIVARIATE METHODOLOGIES TO SPHERICAL DATA AND PLOT   ##
#   STEREONETS AND TERNARY DIAGRAMS IN R                                       ##
#                                                                              ##
#################################################################################
#
# Before we start begin by setting your working directory.#
#
# Today we are going to use some libraries that will let us produce ternary#
# plots and sterenoets in R. You can install these with:#
install.packages("Ternary", dependencies = TRUE)#
install.packages("RFOC", dependencies = TRUE)#
#
# And load them with:#
library(Ternary)#
library(RFOC)#
#
# But before we get into multivariate analysis in R we will do a final visit#
# of the ammonite quadrat data. To do this modify the line below to your own#
# ammonite quadrat:#
QuadratNumber <- "C4"#
#
# From this the following will build a web address (URL) that will point to#
# the correct measurements for your quadrat:#
CSVPath <- paste("http://www.graemetlloyd.com/teaching/SOEE1470/18/",#
  "Ammonite_quadrats/Quadrat_", QuadratNumber, ".csv", sep = "")#
CSVPath
# You can read this data into R with:#
AmmoniteQuadratValues <- read.csv(CSVPath)#
AmmoniteQuadratValues
CSVPath
brosweURL("http://www.graemetlloyd.com/teaching/SOEE1470/18/Ammonite_quadrats/Quadrat_C4.csv")
browseURL("http://www.graemetlloyd.com/teaching/SOEE1470/18/Ammonite_quadrats/Quadrat_C4.csv")
# Load metatree library:#
library(metatree)#
library(Claddis)#
#
# Variables:#
MRPdirectory <- "/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp" # MRP file directory#
XMLdirectory <- "/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/xml" # XML file directory#
waittime <- 0 # Wait time in seconds for avoiding overloading database with queries#
targetclade <- "Temnospondyli" # Select target clade (i.e., what do you want a metatree of)#
archoinclusivedatalist <- c("Acosta_Hospitaleche_etal_2007a", "Adams_2013a", "Adams_2014a", "Agnolin_2007a", "Agnolin_et_Novas_2011a", "Agnolin_et_Novas_2013a", "Agnolin_etal_2012a", "Aires_etal_2014a", "Alcober_et_Martinez_2010a", "Alifanov_et_Averianov_2003a", "Allain_2002a", "Allain_et_Aquesbi_2008a", "Allain_etal_2004a", "Allain_etal_2007a", "Allain_etal_2012a", "Alvarenga_etal_2011a", "Andrade_et_Bertini_2008aa", "Andrade_et_Bertini_2008ab", "Andrade_et_Bertini_2008b", "Andrade_etal_2010a", "Andrade_etal_2011a", "Andres_et_Ji_2008a", "Andres_etal_2010a", "Apaldetti_etal_2011a", "Apaldetti_etal_2013aa", "Apaldetti_etal_2013ab", "Apaldetti_etal_2014aa", "Apaldetti_etal_2014ab", "Apaldetti_etal_2014ac", "Apaldetti_etal_2014ad", "Apesteguia_etal_2016aa", "Apesteguia_etal_2016ab", "Araujo_etal_2013a", "Arbour_et_Currie_2013aa", "Arbour_et_Currie_2013ab", "Arbour_et_Currie_2013ac", "Arbour_et_Currie_2016a", "Arbour_etal_2009a", "Arbour_etal_2014a", "Arbour_etal_2014b", "Arcucci_et_Coria_2003a", "Averianov_et_Sues_2012a", "Averianov_etal_2006a", "Averianov_etal_2010a", "Averianov_inpressa", "Azuma_et_Currie_2000a", "Azuma_etal_2016a", "Bandyopadhyhy_etal_2010a", "Bantim_etal_2014a", "Bapst_etal_2016a", "Barbosa_etal_2008a", "Barco_2005a", "Barco_etal_2006a", "Barrett_etal_2005aa", "Barrett_etal_2005ab", "Barrett_etal_2005ac", "Barrett_etal_2007aa", "Barrett_etal_2007ab", "Barrett_etal_2007ac", "Barrett_etal_2011a", "Barrett_etal_2014a", "Bell_2011a", "Bell_2011b", "Bell_et_Chiappe_2016a", "Bell_et_Currie_2016a", "Bell_et_Evans_2010aa", "Bell_et_Evans_2010ab", "Bell_etal_2010a", "Bell_etal_2014a", "Bell_etal_inpressaa", "Bell_etal_inpressab", "Bennett_1989a", "Bennett_1994a", "Bennett_1996a", "Bennett_2007a", "Bennett_2013aa", "Bennett_2013ab", "Benson_2008a", "Benson_2010a", "Benson_et_Radley_2010a", "Benson_etal_2010a", "Benton_1990a", "Benton_1999a", "Benton_2004a", "Benton_et_Allen_1997a", "Benton_et_Clark_1988aa", "Benton_et_Clark_1988ab", "Benton_et_Walker_2002a", "Benton_et_Walker_2011aa", "Benton_et_Walker_2011ab", "Benton_etal_2000a", "Bertelli_et_Chiappe_2005a", "Bertelli_etal_2006a", "Bertelli_etal_2011a", "Bertelli_etal_2013a", "Bertelli_etal_2014a", "Bhullar_et_Bever_2009a", "Bittencourt_et_Kellner_2009aa", "Bittencourt_et_Kellner_2009ab", "Bittencourt_etal_2015a", "Blanco_etal_2014aa", "Blanco_etal_2014ab", "Bolotsky_et_Godefroit_2004a", "Bolotsky_etal_2014a", "Bonaparte_etal_2006a", "Borsuk-Bialynicka_et_Evans_2009aa", "Borsuk-Bialynicka_et_Evans_2009ab", "Bourdon_2005a", "Bourdon_2011a", "Bourdon_etal_2005a", "Bourdon_etal_2009a", "Boyd_2015a", "Boyd_et_Pagnac_2015a", "Boyd_etal_2009a", "Bravo_et_Gaete_2015a", "Brisson_Egli_etal_inpressa", "Bristowe_et_Raath_2004a", "Brochu_1997ab", "Brochu_1997b", "Brochu_1999a", "Brochu_1999a", "Brochu_2000a", "Brochu_2001a", "Brochu_2003a", "Brochu_2004a", "Brochu_2004b", "Brochu_2006a", "Brochu_2006b", "Brochu_2007a", "Brochu_2007b", "Brochu_2010a", "Brochu_2011a", "Brochu_2013a", "Brochu_et_Gingerich_2000a", "Brochu_et_Jimenez-Vazquez_2014a", "Brochu_et_Rincon_2004a", "Brochu_et_Storrs_2012a", "Brochu_etal_2002a", "Brochu_etal_2010a", "Brochu_etal_2012a", "Bronowicz_2011a", "Bronzati_etal_2012a", "Bronzati_etal_2015aa", "Bronzati_etal_2015ab", "Brown_et_Henderson_2015aa", "Brown_et_Henderson_2015ab", "Brown_etal_2011a", "Brown_etal_2013a", "Brusatte_et_Benson_2013a", "Brusatte_et_Carr_2016a", "Brusatte_et_Sereno_2008a", "Brusatte_etal_2008a", "Brusatte_etal_2009aa", "Brusatte_etal_2009ab", "Brusatte_etal_2009ba", "Brusatte_etal_2009bb", "Brusatte_etal_2010a", "Brusatte_etal_2010b", "Brusatte_etal_2012a", "Brusatte_etal_2013a", "Brusatte_etal_2014a", "Brusatte_etal_2016a", "Buckley_et_Brochu_1999a", "Buckley_etal_2000a", "Burns_et_Currie_2014aa", "Burns_et_Currie_2014ab", "Burns_et_Currie_2014ac", "Burns_et_Currie_2014ad", "Burns_etal_2011a", "Buscalioni_et_Sanz_1988aa", "Buscalioni_et_Sanz_1988ab", "Buscalioni_et_Sanz_1988ac", "Buscalioni_etal_1996a", "Buscalioni_etal_2001a", "Butler_2005a", "Butler_etal_2007a", "Butler_etal_2008a", "Butler_etal_2010a", "Butler_etal_2011aa", "Butler_etal_2011ab", "Butler_etal_2011b", "Butler_etal_2014aa", "Butler_etal_2014ab", "Butler_etal_2014b", "Cabreira_etal_2011aa", "Cabreira_etal_2011ab", "Cabreira_etal_2011ac", "Cabreira_etal_2011ad", "Cabreira_etal_2016a", "Calvo_et_Gonzalez_Riga_2003a", "Calvo_et_Salgado_1995a", "Calvo_etal_2004a", "Calvo_etal_2004b", "Calvo_etal_2007a", "Calvo_etal_2007b", "Calvo_etal_2007c", "Campbell_2015aa", "Campbell_2015ab", "Campbell_etal_2016aa", "Campbell_etal_2016ab", "Campione_etal_2013a", "Canale_etal_2009a", "Canale_etal_2015a", "Canudo_etal_2008a", "Carballido_et_Pol_2010a", "Carballido_et_Sander_2014a", "Carballido_etal_2010a", "Carballido_etal_2011a", "Carballido_etal_2011b", "Carballido_etal_2012a", "Carballido_etal_2012b", "Carballido_etal_2015a", "Carpenter_2001aa", "Carpenter_2001ab", "Carpenter_2001ac", "Carpenter_2001ad", "Carpenter_etal_1998a", "Carpenter_etal_2001a", "Carr_et_Williamson_2004a", "Carr_et_Williamson_2010a", "Carr_etal_2005a", "Carrano_et_Sampson_2008a", "Carrano_etal_2002a", "Carrano_etal_2005a", "Carrano_etal_2012a", "Carvalho_etal_2004a", "Carvalho_etal_2015a", "Casanovas_etal_1999a", "Casanovas_etal_1999b", "Casanovas_etal_2001a", "Cau_et_Arduini_2008a", "Cau_et_Fanti_2011a", "Cau_etal_2012a", "Cau_etal_2013a", "Cau_etal_2015aa", "Cau_etal_2015ab", "Charig_et_Milner_1997a", "Chatterjee_1991a", "Chatterjee_1998a", "Chatterjee_1999a", "Chatterjee_2002a", "Chen_etal_2013a", "Cheng_etal_2016a", "Chiappe_1993a", "Chiappe_1995a", "Chiappe_1996a", "Chiappe_2001a", "Chiappe_2002a", "Chiappe_et_Calvo_1994a", "Chiappe_et_Walker_2002a", "Chiappe_etal_1996a", "Chiappe_etal_1998a", "Chiappe_etal_2007a", "Chinnery_2004a", "Chinnery_et_Horner_2007a", "Chinnery_et_Weishampel_1998a", "Choiniere_etal_2010a", "Choiniere_etal_2010b", "Choiniere_etal_2012a", "Choiniere_etal_2014a", "Choiniere_etal_2014ba", "Choiniere_etal_2014bb", "Chure_etal_2010a", "Clark_1994a", "Clark_et_Sues_2002aa", "Clark_et_Sues_2002ab", "Clark_et_Sues_2002ac", "Clark_et_Sues_2002ad", "Clark_etal_2000aa", "Clark_etal_2000ab", "Clark_etal_2002a", "Clark_etal_2004a", "Clark_etal_2004b", "Clarke_2004aa", "Clarke_2004ab", "Clarke_et_Chiappe_2001a", "Clarke_et_Middleton_2008a", "Clarke_et_Norell_2002a", "Clarke_et_Norell_2004a", "Clarke_etal_2005aa", "Clarke_etal_2005ab", "Clarke_etal_2005ac", "Clarke_etal_2005ba", "Clarke_etal_2005bb", "Clarke_etal_2006a", "Clarke_etal_2007a", "Codorniu_etal_2016aa", "Codorniu_etal_2016ab", "Company_etal_2005a", "Conrad_etal_2013a", "Coria_et_Currie_2002a", "Coria_et_Currie_2006a", "Coria_et_Currie_2016aa", "Coria_et_Currie_2016ab", "Coria_et_Salgado_1996a", "Coria_etal_2002a", "Coria_etal_2013a", "Cracraft_et_Clarke_2001a", "Cruzado-Caballero_etal_2013a", "Cruzardo-Caballero_etal_2010a", "Csiki_etal_2010a", "Csiki_etal_2010ba", "Csiki_etal_2010bb", "Csiki_etal_2010bc", "Csiki_etal_2010bd", "Cullen_etal_2013a", "Currie_1995a", "Currie_et_Carpenter_2000a", "Currie_et_Varricchio_2004a", "Currie_etal_2003a", "Currie_etal_2008a", "Currie_etal_2016aa", "Currie_etal_2016ab", "Curry_Rogers_2005a", "Curry_Rogers_et_Forster_2001a", "Cuthbertson_et_Holmes_2010a", "Dal_Sasso_et_Maganuco_2011a", "Dalla_Vecchia_2009a", "Dalla_Vecchia_2009b", "Dalla_Vecchia_2009c", "De_Pietri_etal_2011a", "Dececchi_etal_2012a", "Delfino_et_De_Vos_2010a", "Delfino_et_Rook_2008a", "Delfino_et_Smith_2009a", "Delfino_et_Smith_2012a", "Delfino_etal_2005a", "Delfino_etal_2008aa", "Delfino_etal_2008ab", "Delfino_etal_2008b", "DEmic_2012a", "DEmic_2013a", "DEmic_etal_2016a", "Densmore_et_White_1991aa", "Densmore_et_White_1991ab", "Desojo_etal_2011a", "Desojo_etal_2012a", "Diez_Diaz_etal_inpressa", "Dilkes_1995a", "Dilkes_1998a", "Dilkes_et_Arcucci_inpressa", "Dilkes_et_Sues_2009a", "Dodson_etal_2004a", "Drymala_et_Zanno_2016a", "Dyke_etal_2003a", "Eddy_et_Clarke_2011a", "Elzanowski_1999a", "Escaso_etal_2007a", "Escaso_etal_2014a", "Evans_1990a", "Evans_2010a", "Evans_et_Klembara_2005a", "Evans_et_Manabe_1999a", "Evans_et_Reisz_2007a", "Evans_et_Ryan_2015a", "Evans_etal_2013a", "Evans_etal_2013ba", "Evans_etal_2013bb", "Evers_etal_2015a", "Ezcurra_2006a", "Ezcurra_2010a", "Ezcurra_2016a", "Ezcurra_et_Apaldetti_2012a", "Ezcurra_et_Brusatte_2011a", "Ezcurra_et_Cuny_2007a", "Ezcurra_et_Novas_2007a", "Ezcurra_etal_2010a", "Ezcurra_etal_2010b", "Ezcurra_etal_2016a", "Fanti_etal_2012a", "Fanti_etal_2013a", "Fanti_etal_2015a", "Fanti_etal_2016a", "Farke_et_Patel_2012a", "Farke_et_Sertich_2013a", "Farke_etal_2009a", "Farke_etal_2011aa", "Farke_etal_2011ab", "Farke_etal_2014a", "Farke_etal_2014ba", "Farke_etal_2014bb", "Fernandez-Baldor_etal_2011a", "Filippi_etal_2011a", "Fiorelli_et_Calvo_2007a", "Fiorelli_et_Calvo_2008aa", "Fiorelli_et_Calvo_2008ab", "Fiorillo_et_Tykoski_2012a", "Fiorillo_et_Tykoski_2014aa", "Fiorillo_et_Tykoski_2014ab", "Fitzgerald_etal_2012a", "Forster_1999a", "Forster_etal_1993a", "Forster_etal_1998a", "Fortier_et_Schultz_2009a", "Fortier_etal_2011a", "Fortier_etal_2014a", "Foth_etal_2014a", "Franca_etal_2011a", "Frank-Hoeflich_etal_2007aa", "Frank-Hoeflich_etal_2007ab", "Frankfurt_et_Chiappe_1999a", "Frederickson_et_Tumarkin-Deratzian_2014aa", "Frederickson_et_Tumarkin-Deratzian_2014ab", "Frederickson_et_Tumarkin-Deratzian_2014ac", "Frederickson_et_Tumarkin-Deratzian_2014ad", "Freedman_Fowler_et_Horner_2015aa", "Freedman_Fowler_et_Horner_2015ab", "Freedman_Fowler_et_Horner_2015ac", "Funston_et_Currie_inpressa", "Gallina_et_Apesteguia_2005a", "Gallina_et_Apesteguia_2011a", "Gallina_et_Otero_2015a", "Gallina_etal_2014aa", "Gallina_etal_2014ab", "Galton_et_Upchurch_2004a", "Galton_et_Upchurch_2004b", "Gao_et_Fox_1998a", "Gao_et_Fox_2005a", "Gao_etal_2008a", "Gao_etal_2012a", "Gao_etal_2013aa", "Gao_etal_2013ab", "Garcia_etal_2006a", "Gasca_etal_2015a", "Gasparini_etal_1991a", "Gasparini_etal_1993a", "Gasparini_etal_2006a", "Gasulla_etal_2014a", "Gasulla_etal_2015aa", "Gasulla_etal_2015ab", "Gates_et_Sampson_2007a", "Gates_et_Scheetz_2015aa", "Gates_et_Scheetz_2015ab", "Gates_etal_2007a", "Gates_etal_2011a", "Gates_etal_2014aa", "Gates_etal_2014ab", "Gatesy_etal_2003a", "Gauthier_1986a", "Gauthier_etal_1988a", "Gauthier_etal_1988b", "Gay_2010a", "Gianechini_etal_2015a", "Giannini_et_Bertelli_2005a", "Godefroit_etal_1998a", "Godefroit_etal_2000a", "Godefroit_etal_2001a", "Godefroit_etal_2003a", "Godefroit_etal_2004a", "Godefroit_etal_2004b", "Godefroit_etal_2008a", "Godefroit_etal_2012a", "Godefroit_etal_2012b", "Godefroit_etal_2013a", "Godefroit_etal_2013b", "Godefroit_etal_2014a", "Godoy_etal_2014a", "Godoy_etal_2016a", "Gohlich_et_Chiappe_2006a", "Gomani_1997a", "Gonzalez_Riga_2003a", "Gonzalez_Riga_et_David_2014a", "Gonzalez_Riga_etal_2016a", "Gorscak_etal_2014a", "Gottmann-Quesada_et_Sander_2009a", "Gower_2002a", "Gower_et_Nesbitt_2006a", "Gower_et_Sennikov_1996a", "Gower_et_Sennikov_1997a", "Grellet-Tinner_2006a", "Grellet-Tinner_et_Chiappe_2004a", "Grellet-Tinner_et_Makovicky_2006a", "Gulas-Wroblewski_et_Wroblewski_2003a", "Halliday_etal_2015a", "Han_etal_2012a", "Han_etal_2014a", "Han_etal_2014b", "Han_etal_2015a", "Harris_1998a", "Harris_2006a", "Harris_et_Dodson_2004a", "Harris_etal_2003aa", "Harris_etal_2003ab", "Harris_etal_2003ac", "Harris_etal_2003ad", "Hastings_etal_2010a", "Hastings_etal_2011a", "Hastings_etal_2013a", "He_etal_2013a", "He_etal_2015a", "Head_1998a", "Head_2001a", "Headden_et_Campos_2015a", "Hecht_1992a", "Heckert_et_Lucas_1999a", "Heckert_etal_1996aa", "Heckert_etal_1996ab", "Heckert_etal_2015a", "Hendrickx_et_Mateus_2014aa", "Hendrickx_et_Mateus_2014ab", "Hendrickx_et_Mateus_2014b", "Herrera_etal_2013aa", "Herrera_etal_2013ab", "Herrera_etal_2015a", "Hill_etal_2003a", "Hill_etal_2008a", "Hocknull_etal_2009aa", "Hocknull_etal_2009ab", "Hocknull_etal_2009ac", "Holliday_et_Gardner_2012aa", "Holliday_et_Gardner_2012ab", "Holmes_etal_2001aa", "Holmes_etal_2001ab", "Holtz_1994a", "Holtz_1998a", "Holtz_2001a", "Holtz_2001b", "Holtz_etal_2004a", "Hone_et_Benton_2008a", "Horner_etal_2004a", "Hou_etal_1996a", "Hu_et_OConnor_inpressa", "Hu_etal_2009a", "Hu_etal_2010a", "Hu_etal_2011a", "Hu_etal_2012a", "Hu_etal_2014a", "Hu_etal_2015a", "Hua_et_Jouve_2004a", "Huang_etal_2016a", "Hungerbuhler_2001a", "Hungerbuhler_2002a", "Hungerbuhler_etal_2013a", "Hutchinson_2001a", "Hutchinson_2002a", "Hwang_etal_2002a", "Hwang_etal_2004a", "Iori_et_Carvalho_2011a", "Iori_etal_2013a", "Irmis_etal_2007a", "Irmis_etal_2013a", "Jalil_1997a", "James_2004aa", "James_2004ab", "James_2004ac", "James_et_Pourtless_2009aa", "James_et_Pourtless_2009ab", "Janoo_2000a", "Ji_etal_1998a", "Ji_etal_2003a", "Ji_etal_2005a", "Ji_etal_2011a", "Jin_etal_2012a", "Johnston_2011a", "Jouve_2005a", "Jouve_etal_2005a", "Jouve_etal_2006a", "Jouve_etal_2006b", "Jouve_etal_2008a", "Jouve_etal_2008b", "Jouve_etal_2015a", "Juul_1994a", "Kammerer_etal_2012ba", "Kammerer_etal_2012bb", "Kammerer_etal_2016a", "Kellner_2003a", "Kellner_2004a", "Kellner_etal_2014a", "Kim_etal_2005a", "Kirkland_1998a", "Kirkland_1998b", "Kirkland_etal_2005a", "Knoll_2008a", "Knoll_2010a", "Kobayashi_et_Azuma_2003a", "Kobayashi_et_Lu_2003a", "Ksepka_et_Clarke_2009a", "Ksepka_et_Clarke_2010a", "Ksepka_et_Clarke_2012a", "Ksepka_et_Norell_2006a", "Ksepka_et_Norell_2010a", "Ksepka_etal_2005a", "Ksepka_etal_2006a", "Kurochkin_1996a", "Kurochkin_etal_2011a", "Kurochkin_etal_2013a", "Kutty_etal_2007aa", "Kutty_etal_2007ab", "Lacerda_etal_2016a", "Lacovara_etal_2014a", "Lamanna_etal_2002a", "Lamanna_etal_2006a", "Lamanna_etal_2014a", "Lang_et_Mahammed_2010a", "Langer_2004a", "Langer_et_Benton_2006a", "Langer_et_Ferigolo_2013a", "Langer_et_Schultz_2000a", "Langer_etal_2011aa", "Langer_etal_2011ab", "Langer_etal_2014a", "Larson_etal_2014a", "Larsson_et_Gado_2000a", "Larsson_et_Sues_2007a", "Lauprasert_etal_2007a", "Lauprasert_etal_2009a", "Lautenschlager_et_Rauhut_2015aa", "Lautenschlager_et_Rauhut_2015ab", "Leal_etal_2004a", "Leardi_et_Pol_2009a", "Leardi_etal_2012aa", "Leardi_etal_2012ab", "Leardi_etal_2012ac", "Leardi_etal_2015a", "Lee_1996a", "Lee_et_Worthy_2012a", "Lee_etal_2011a", "Lee_etal_2014a", "Lee_etal_2014b", "Lee_etal_2014c", "Lehman_1996a", "Lehman_etal_2016a", "Lessner_etal_2016a", "Li_etal_2004aa", "Li_etal_2004ab", "Li_etal_2006a", "Li_etal_2007a", "Li_etal_2008b", "Li_etal_2010a", "Li_etal_2012a", "Li_etal_2014a", "Li_etal_2014ba", "Li_etal_2014bb", "Li_etal_2014bc", "Liu_etal_2014b", "Liu_etal_2015a", "Livezey_1996a", "Livezey_1997a", "Livezey_1998aa", "Livezey_1998ab", "Livezey_et_Zusi_2007a", "Loewen_etal_2010a", "Loewen_etal_2013a", "Longrich_2006a", "Longrich_2010a", "Longrich_2011aa", "Longrich_2011ab", "Longrich_2013a", "Longrich_2014a", "Longrich_et_Currie_2009a", "Longrich_et_Currie_2009b", "Longrich_etal_2010a", "Longrich_etal_2010b", "Longrich_etal_2011a", "Longrich_etal_2013a", "Lopez-Martinez_et_Vicens_2012a", "Lovelace_etal_2007a", "Lu_et_Brusatte_2015a", "Lu_et_Ji_2006a", "Lu_etal_2002a", "Lu_etal_2004a", "Lu_etal_2007a", "Lu_etal_2007b", "Lu_etal_2008a", "Lu_etal_2010aa", "Lu_etal_2010ab", "Lu_etal_2010b", "Lu_etal_2012a", "Lu_etal_2012c", "Lu_etal_2013a", "Lu_etal_2013b", "Lu_etal_2013c", "Lu_etal_2014aa", "Lu_etal_2014ab", "Lu_etal_2014ac", "Lu_etal_2015a", "Lu_etal_2015b", "Lu_etal_2016a", "Lu_etal_2016b", "Lund_etal_2016a", "Lund_etal_2016b", "Maganuco_etal_2007a", "Maidment_2010a", "Maidment_etal_2006a", "Maidment_etal_2008a", "Maisch_etal_2004a", "Makovicky_2001a", "Makovicky_2010aa", "Makovicky_2010ab", "Makovicky_et_Norell_2004a", "Makovicky_et_Norell_2006aa", "Makovicky_et_Norell_2006ab", "Makovicky_et_Sues_1998a", "Makovicky_etal_2003a", "Makovicky_etal_2004a", "Makovicky_etal_2005aa", "Makovicky_etal_2005ab", "Makovicky_etal_2010a", "Makovicky_etal_2011a", "Makovicky_etal_2012a", "Mallon_etal_2011a", "Mallon_etal_2014aa", "Mallon_etal_2014ab", "Mallon_etal_2016aa", "Mallon_etal_2016ab", "Manegold_et_Louchart_2012a", "Manegold_et_Topfer_2012a", "Mannion_2011aa", "Mannion_2011ab", "Mannion_2011ac", "Mannion_etal_2012aa", "Mannion_etal_2012ab", "Mannion_etal_2013a", "Martill_et_Naish_2006a", "Martill_etal_2016a", "Martin_1997a", "Martin_2010a", "Martin_et_Buffetaut_2008a", "Martin_et_Buffetaut_2012aa", "Martin_et_Buffetaut_2012ab", "Martin_et_Gross_2011a", "Martin_et_Lauprasert_2010aa", "Martin_et_Lauprasert_2010ab", "Martin_et_Vincent_2013a", "Martin_etal_2010aa", "Martin_etal_2010ab", "Martin_etal_2010ac", "Martin_etal_2014a", "Martin_etal_2016a", "Martinelli_2003a", "Martinelli_et_Vera_2007a", "Martinez_2009a", "Martinez_et_Alcober_2009a", "Martinez_etal_2011a", "Martinez_etal_2012a", "Martinez_etal_2016aa", "Martinez_etal_2016ab", "Martinez_etal_2016ac", "Martinez_etal_2016ad", "Maryanska_etal_2002a", "Maryanska_etal_2004a", "Mastrantonio_etal_2013a", "Mateus_etal_2009a", "Mateus_etal_2011aa", "Mateus_etal_2011ab", "Matsumoto_etal_2007a", "Matsumoto_etal_2009aa", "Matsumoto_etal_2009ab", "Matsumoto_etal_2009ac", "Matsumoto_etal_2009ad", "Matsumoto_etal_2013a", "Mauricio_etal_2012a", "Mayr_2003a", "Mayr_2003b", "Mayr_2003c", "Mayr_2004a", "Mayr_2004b", "Mayr_2004c", "Mayr_2005b", "Mayr_2005c", "Mayr_2005d", "Mayr_2006a", "Mayr_2008a", "Mayr_2008b", "Mayr_2008c", "Mayr_2010a", "Mayr_2011a", "Mayr_2011b", "Mayr_2011c", "Mayr_2011d", "Mayr_2013a", "Mayr_2013b", "Mayr_2015a", "Mayr_et_Clarke_2003a", "Mayr_et_De_Pietri_2014a", "Mayr_et_Mourer-Chauvire_2004a", "Mayr_et_Noriega_2015a", "Mayr_et_Smith_2012a", "Mayr_etal_2003a", "Mayr_etal_2004a", "Mayr_etal_2005a", "Mayr_etal_2010a", "Mayr_etal_2011a", "Mayr_etal_2015aa", "Mayr_etal_2015ab", "McDonald_2011a", "McDonald_2011b", "McDonald_2012aa", "McDonald_2012ab", "McDonald_et_Horner_2010a", "McDonald_etal_2010a", "McDonald_etal_2010b", "McDonald_etal_2010c", "McDonald_etal_2012a", "McFeeters_etal_2013a", "McGarrity_etal_2013a", "McPhee_etal_2015a", "McPhee_etal_2015b", "Mo_2013a", "Mo_etal_2007a", "Mo_etal_2010a", "Modesto_et_Sues_2004a", "Montefeltro_etal_2011a", "Montefeltro_etal_2013a", "Montefeltro_etal_2013b", "Mori_etal_2016aa", "Mori_etal_2016ab", "Mori_etal_2016ac", "Mori_etal_2016ad", "Mueller-Towe_2005a", "Mukherjee_et_Ray_2014a", "Muller_2004a", "Munter_et_Clark_2006aa", "Munter_et_Clark_2006ab", "Murray_et_Vickers-Rich_2004aa", "Murray_et_Vickers-Rich_2004ab", "Murray_et_Vickers-Rich_2004ac", "Murray_et_Vickers-Rich_2004ad", "Murray_et_Vickers-Rich_2004ae", "Nair_et_Salisbury_2012a", "Naish_et_Martill_2002a", "Naish_etal_2012a", "Naish_etal_2013aa", "Naish_etal_2013ab", "Narvaez_etal_2015a", "Nascimento_et_Zaher_2011a", "Nesbitt_2003a", "Nesbitt_2007a", "Nesbitt_2011aa", "Nesbitt_2011ab", "Nesbitt_et_Butler_2013aa", "Nesbitt_et_Butler_2013ab", "Nesbitt_et_Ezcurra_2015aa", "Nesbitt_et_Ezcurra_2015ab", "Nesbitt_etal_2009a", "Nesbitt_etal_2009b", "Nesbitt_etal_2009c", "Nesbitt_etal_2009d", "Nesbitt_etal_2010a", "Nesbitt_etal_2011a", "Nesbitt_etal_2011b", "Nesbitt_etal_2013aa", "Nesbitt_etal_2013ab", "Nesbitt_etal_2014aa", "Nesbitt_etal_2014ab", "Nesbitt_etal_2015a", "Nguyen_etal_2010aa", "Nguyen_etal_2010ab", "Niedzwiedzki_etal_2014a", "Niedzwiedzki_etal_2016a", "Norell_1989a", "Norell_et_Clark_1990a", "Norell_et_Clarke_2001a", "Norell_et_Makovicky_2004a", "Norell_etal_2000a", "Norell_etal_2001a", "Norell_etal_2006aa", "Norell_etal_2006ab", "Norell_etal_2006ac", "Noriega_etal_2011a", "Norman_2002a", "Norman_2004a", "Norman_2014a", "Norman_2015a", "Norman_etal_2004a", "Norman_etal_2004b", "Norman_etal_2011a", "Novas_1989a", "Novas_1992a", "Novas_1993a", "Novas_1996a", "Novas_1996b", "Novas_1997a", "Novas_et_Pol_2005a", "Novas_etal_2004a", "Novas_etal_2005a", "Novas_etal_2008a", "Novas_etal_2009a", "Novas_etal_2009b", "Novas_etal_2011a", "Novas_etal_2012a", "Novas_etal_2013aa", "Novas_etal_2013ab", "Novas_etal_2015aa", "Novas_etal_2015ab", "Novas_etal_2015ac", "Novas_etal_2015ad", "OConnor_et_Zhou_2013a", "OConnor_etal_2009a", "OConnor_etal_2010a", "OConnor_etal_2010b", "OConnor_etal_2011a", "OConnor_etal_2013a", "OConnor_etal_2014aa", "OConnor_etal_2014ab", "OConnor_etal_2016b", "OConnor_etal_inpressa", "Ohashi_et_Barrett_2009a", "OLeary_etal_2004aa", "OLeary_etal_2004ab", "Olsen_etal_2000a", "Ortega_etal_1996a", "Ortega_etal_2000a", "Ortega_etal_2010a", "Osi_2005a", "Osi_et_Makadi_2009a", "Osi_etal_2012aa", "Osi_etal_2012ab", "Osmolska_etal_2004a", "Otero_et_Pol_2013a", "Ott_et_Larson_2010a", "Parker_2007a", "Parker_2016a", "Parker_et_Barton_2008a", "Parker_et_Irmis_2006a", "Parker_etal_2008a", "Parrilla-Bel_etal_2013a", "Parrish_1991a", "Parrish_1992a", "Parrish_1993a", "Parrish_1994a", "Parsons_et_Parsons_2009a", "Parsons_et_Parsons_2015a", "Peecook_etal_2013a", "Pei_etal_2014a", "Penkalski_2014a", "Penkalski_et_Dodson_1999a", "Pereda-Suberbiola_etal_2009a", "Pereda-Suberbiola_etal_2012a", "Perez-Moreno_etal_1993a", "Perez-Moreno_etal_1994a", "Peters_2000aa", "Peters_2000ab", "Peters_2000ac", "Peyre_de_Fabregues_et_Allain_2016a", "Pinheiro_etal_2011a", "Pinheiro_etal_2016a", "Piras_et_Buscalioni_2006a", "Pisani_etal_2002a", "Pol_2003a", "Pol_et_Apesteguia_2005a", "Pol_et_Gasparini_2009a", "Pol_et_Norell_2004a", "Pol_et_Norell_2004b", "Pol_et_Powell_2011a", "Pol_et_Rauhut_2012a", "Pol_etal_2004a", "Pol_etal_2009a", "Pol_etal_2011a", "Pol_etal_2011b", "Pol_etal_2012a", "Pol_etal_2013a", "Pol_etal_2014a", "Porfiri_etal_2014a", "Poropat_etal_2015aa", "Poropat_etal_2015ab", "Poropat_etal_2015ba", "Poropat_etal_2015bb", "Poropat_etal_2016a", "Pretto_etal_2015a", "Prieto-Marquez_2005a", "Prieto-Marquez_2010a", "Prieto-Marquez_2010b", "Prieto-Marquez_2011a", "Prieto-Marquez_2012a", "Prieto-Marquez_2014aa", "Prieto-Marquez_2014ab", "Prieto-Marquez_2014b", "Prieto-Marquez_et_Norell_2010a", "Prieto-Marquez_et_Salinas_2010a", "Prieto-Marquez_et_Wagner_2009a", "Prieto-Marquez_et_Wagner_2013a", "Prieto-Marquez_etal_2006a", "Prieto-Marquez_etal_2006b", "Prieto-Marquez_etal_2012a", "Prieto-Marquez_etal_2012b", "Prieto-Marquez_etal_2013a", "Pritchard_etal_2015aa", "Pritchard_etal_2015ab", "Pu_etal_2013a", "Puertolas_etal_2011a", "Puertolas-Pascual_etal_2015aa", "Puertolas-Pascual_etal_2015ab", "Rabi_et_Sebok_2015a", "Ramirez-Velasco_etal_2012a", "Rauhut_2003a", "Rauhut_2006a", "Rauhut_et_Carrano_inpressa", "Rauhut_et_Xu_2005a", "Rauhut_etal_2005a", "Rauhut_etal_2010a", "Rauhut_etal_2012ba", "Rauhut_etal_2012bb", "Rauhut_etal_2012bc", "Rauhut_etal_2015a", "Rauhut_etal_2016a", "Remes_2006a", "Remes_etal_2009a", "Renesto_et_Binelli_2006a", "Renesto_etal_2010aa", "Renesto_etal_2010ab", "Renesto_etal_2010ac", "Rieppel_etal_2003ba", "Rieppel_etal_2003bb", "Riff_et_Kellner_2011a", "Riga_etal_2009a", "Rivera-Sylva_etal_2016a", "Roberto-da-Silva_etal_2014a", "Rodrigues_et_Kellner_2013a", "Rogers_2003a", "Rose_2007a", "Rowe_etal_2011aa", "Rowe_etal_2011ab", "Royo-Torres_et_Upchurch_2012aa", "Royo-Torres_et_Upchurch_2012ab", "Royo-Torres_etal_2006a", "Royo-Torres_etal_2009a", "Royo-Torres_etal_2012aa", "Royo-Torres_etal_2012ab", "Royo-Torres_etal_2012ac", "Royo-Torres_etal_2012ad", "Royo-Torres_etal_2014aa", "Royo-Torres_etal_2014ab", "Rozadilla_etal_2016a", "Rubilar-Rogers_etal_2012a", "Ruiz-Omenaca_etal_1997a", "Ruiz-Omenaca_etal_2012a", "Russell_et_Dong_1993a", "Russell_et_Zheng_1993a", "Ryan_2007aa", "Ryan_2007ab", "Ryan_et_Russell_2005aa", "Ryan_et_Russell_2005ab", "Ryan_etal_2010a", "Ryan_etal_2012a", "Ryan_etal_2012ba", "Ryan_etal_2012bb", "Sadleir_etal_2008aa", "Sadleir_etal_2008ab", "Saegusa_et_Ikeda_2014a", "Salas-Gismondi_etal_2015a", "Salas-Gismondi_etal_2016a", "Salgado_etal_1997a", "Salgado_etal_2004a", "Salgado_etal_2006a", "Salgado_etal_2015a", "Salisbury_etal_2006a", "Sampson_1995a", "Sampson_etal_2010a", "Sampson_etal_2013a", "Sanchez-Hernandez_et_Benton_2014a", "Sander_etal_2006aa", "Sander_etal_2006ab", "Sander_etal_2006ac", "Santucci_2008aa", "Santucci_2008ab", "Santucci_et_Arruda-Campos_2011a", "Sanz_et_Buscalioni_1992a", "Sanz_etal_1995aa", "Sanz_etal_1995ab", "Sanz_etal_1996a", "Sanz_etal_1999a", "Scheyer_etal_2013aa", "Scheyer_etal_2013ab", "Schoch_et_Desojo_2016a", "Schoch_et_Sues_2014a", "Schott_etal_2009aa", "Schott_etal_2009ab", "Schultz_etal_inpressa", "Sekiya_2010a", "Sekiya_2011aa", "Sekiya_2011ab", "Sekiya_etal_2014a", "Senter_2004aa", "Senter_2004ab", "Senter_2007a", "Senter_2010a", "Senter_2011a", "Senter_etal_2004a", "Senter_etal_2010a", "Senter_etal_2012a", "Senter_etal_2012b", "Sereno_1991a", "Sereno_1993a", "Sereno_1999aa", "Sereno_1999ab", "Sereno_1999ac", "Sereno_1999ad", "Sereno_1999ae", "Sereno_1999af", "Sereno_1999ag", "Sereno_1999ah", "Sereno_1999ai", "Sereno_2000aa", "Sereno_2000ab", "Sereno_2010a", "Sereno_2012a", "Sereno_et_Arcucci_1990a", "Sereno_et_Arcucci_1994a", "Sereno_et_Arcucci_1994b", "Sereno_et_Brusatte_2008aa", "Sereno_et_Brusatte_2008ab", "Sereno_et_Dong_1992a", "Sereno_et_Larsson_2009a", "Sereno_et_Wild_1992aa", "Sereno_et_Wild_1992ab", "Sereno_et_Wild_1992ac", "Sereno_etal_1996a", "Sereno_etal_1998a", "Sereno_etal_2001a", "Sereno_etal_2003a", "Sereno_etal_2004a", "Sereno_etal_2007a", "Sereno_etal_2009a", "Sertich_et_Loewen_2010aa", "Sertich_et_Loewen_2010ab", "Sertich_et_OConnor_2014a", "Shibata_etal_2015a", "Skutchas_2008a", "Skutschas_etal_2014a", "Slack_etal_2006a", "Smith_2010a", "Smith_2011aa", "Smith_2011ab", "Smith_et_Clarke_2012a", "Smith_et_Pol_2007a", "Smith_etal_2001a", "Smith_etal_2007a", "Smith_etal_2008a", "Smith_etal_2013a", "Snyder_2007aa", "Snyder_2007ab", "Sookias_etal_2014b", "Sookias_etal_2014ca", "Sookias_etal_2014cb", "Soto_etal_2011a", "Spielman_etal_2008aa", "Spielman_etal_2008ab", "Spielman_etal_2008ac", "Stocker_2010a", "Stocker_2012a", "Stocker_etal_inpressa", "Sues_1997a", "Sues_2003a", "Sues_et_Averianov_2009a", "Sues_et_Averianov_2009b", "Sues_et_Averianov_2014aa", "Sues_et_Averianov_2014ab", "Sues_et_Schoch_2013a", "Sues_etal_2003a", "Sues_etal_2011a", "Sullivan_2003a", "Sullivan_etal_2011a", "Suteethorn_etal_2010a", "Suzuki_etal_2004a", "Sweetman_etal_2015a", "Taylor_2009a", "Taylor_et_Naish_2007a", "Taylor_etal_2011a", "Thomas_2015a", "Thompson_etal_2012a", "Toljagic_et_Butler_2013a", "Tomida_et_Tsumura_2006a", "Tortosa_etal_2014a", "Trotteyn_et_Ezcurra_2014a", "Trotteyn_et_Haro_2012a", "Tschopp_et_Mateus_2013a", "Tschopp_etal_2015a", "Tsogtbaatar_etal_2014a", "Tsuihiji_etal_2011aa", "Tsuihiji_etal_2011ab", "Tsuihiji_etal_2012a", "Tsuihiji_etal_2014a", "Tsuihiji_etal_2016a", "Turner_2004a", "Turner_2006a", "Turner_2015a", "Turner_et_Buckley_2008a", "Turner_et_Sertich_2010a", "Turner_etal_2007a", "Turner_etal_2007b", "Turner_etal_2011a", "Turner_etal_2012a", "Tykoski_et_Fiorillo_inpressaa", "Tykoski_et_Fiorillo_inpressab", "Tykoski_et_Rowe_2004a", "Tykoski_etal_2002aa", "Tykoski_etal_2002ab", "Tykoski_etal_2002ac", "Unwin_2003a", "Unwin_2003b", "Upchurch_1995a", "Upchurch_1998a", "Upchurch_1999a", "Upchurch_et_Mannion_2009aa", "Upchurch_et_Mannion_2009ab", "Upchurch_et_Martin_2002aa", "Upchurch_et_Martin_2002ab", "Upchurch_etal_2004a", "Upchurch_etal_2004b", "Upchurch_etal_2007ba", "Upchurch_etal_2007bb", "VanBuren_etal_2015a", "Varricchio_2002a", "Varricchio_et_Chiappe_1995a", "Varricchio_et_Jackson_2004a", "Varricchio_etal_2007a", "Velez-Juarbe_etal_2007a", "Verdu_etal_2015a", "Vickaryous_etal_2001a", "Vickaryous_etal_2004a", "Vila_Nova_etal_2014aa", "Vila_Nova_etal_2014ab", "Vila_Nova_etal_2014ac", "von_Baczko_etal_2014a", "Vullo_etal_2012a", "Wang_et_Liu_2016a", "Wang_etal_2005c", "Wang_etal_2008a", "Wang_etal_2009a", "Wang_etal_2012a", "Wang_etal_2012b", "Wang_etal_2012ca", "Wang_etal_2012cb", "Wang_etal_2013b", "Wang_etal_2013c", "Wang_etal_2013d", "Wang_etal_2013e", "Wang_etal_2014a", "Wang_etal_2014b", "Wang_etal_2014c", "Wang_etal_2014d", "Wang_etal_2014e", "Wang_etal_2014f", "Wang_etal_2015a", "Wang_etal_2015b", "Wang_etal_2016a", "Wang_etal_2016ba", "Wang_etal_2016bb", "Wang_etal_2016c", "Wang_etal_inpressd", "Watabe_etal_2011a", "Weckstein_2005a", "Weinbaum_et_Hungerbuhler_2007a", "Weishampel_et_Heinrich_1992a", "Weishampel_etal_1993a", "Weishampel_etal_2003a", "Whitlock_2011a", "Whitlock_2011ba", "Whitlock_2011bb", "Wilberg_2015a", "Wilberg_2015ba", "Wilberg_2015bb", "Wilberg_2015bc", "Wilberg_2015bd", "Wilkinson_etal_2008a", "Williamson_1996a", "Williamson_et_Brusatte_2016a", "Williamson_et_Carr_2002a", "Willis_1997a", "Wilson_2002a", "Wilson_2005aa", "Wilson_2005ab", "Wilson_et_Allain_2015a", "Wilson_et_Sereno_1998a", "Wilson_et_Upchurch_2009aa", "Wilson_et_Upchurch_2009ab", "Wilson_etal_2003a", "Wilson_etal_inpressa", "Winkler_etal_1997a", "Witton_2012a", "Worthy_2009a", "Worthy_et_Scofield_2012a", "Worthy_etal_2010a", "Worthy_etal_2014a", "Wu_et_Brinkman_1993a", "Wu_et_Chatterjee_1993a", "Wu_et_Godefroit_2012a", "Wu_et_Sues_1996a", "Wu_etal_1994a", "Wu_etal_1994b", "Wu_etal_1996a", "Wu_etal_1997a", "Wu_etal_2001a", "Wu_etal_2007a", "Wu_etal_2013b", "Xing_etal_2012a", "Xing_etal_2014a", "Xing_etal_2014b", "Xing_etal_2015a", "Xing_etal_2015b", "Xu_et_Han_2010a", "Xu_et_Norell_2004a", "Xu_et_Wang_2004a", "Xu_et_Zhang_2005a", "Xu_etal_1999a", "Xu_etal_1999b", "Xu_etal_2000a", "Xu_etal_2000b", "Xu_etal_2001a", "Xu_etal_2002a", "Xu_etal_2002b", "Xu_etal_2002c", "Xu_etal_2004a", "Xu_etal_2006a", "Xu_etal_2006b", "Xu_etal_2007aa", "Xu_etal_2007ab", "Xu_etal_2009a", "Xu_etal_2009b", "Xu_etal_2010a", "Xu_etal_2010ba", "Xu_etal_2010bb", "Xu_etal_2011a", "Xu_etal_2011b", "Xu_etal_2011c", "Xu_etal_2011d", "Xu_etal_2012aa", "Xu_etal_2012ab", "Xu_etal_2012ac", "Xu_etal_2012ba", "Xu_etal_2012bb", "Xu_etal_2013a", "Xu_etal_2013b", "Xu_etal_2015a", "Yang_etal_2013a", "Yates_2003a", "Yates_2003b", "Yates_2004aa", "Yates_2004ab", "Yates_2005a", "Yates_2007a", "Yates_2010a", "Yates_et_Kitching_2003a", "Yates_etal_2010aa", "Yates_etal_2010ab", "Yates_etal_2011aa", "Yates_etal_2011ab", "You_2003a", "You_et_Dodson_2003a", "You_et_Dodson_2004a", "You_et_Li_2009a", "You_etal_2003a", "You_etal_2003b", "You_etal_2005a", "You_etal_2006a", "You_etal_2006b", "You_etal_2008a", "You_etal_2008b", "You_etal_2010a", "You_etal_2014a", "Young_et_Andrade_2009a", "Young_etal_2011aa", "Young_etal_2011ab", "Young_etal_2012a", "Young_etal_2013a", "Zaher_etal_2006a", "Zaher_etal_2011a", "Zanno_2006a", "Zanno_2010a", "Zanno_et_Makovicky_2011aa", "Zanno_et_Makovicky_2011ab", "Zanno_et_Makovicky_2011ac", "Zanno_et_Makovicky_2013a", "Zanno_etal_2009a", "Zanno_etal_2011a", "Zanno_etal_2015aa", "Zanno_etal_2015ab", "Zelenitsky_et_Therrien_2008a", "Zelenkov_et_Dyke_2008a", "Zhang_et_Zhou_2000a", "Zhang_etal_2002a", "Zhang_etal_2008a", "Zhang_etal_2008b", "Zhao_etal_1999a", "Zheng_etal_2009a", "Zheng_etal_2010a", "Zheng_etal_2014a", "Zheng_etal_2015a", "Zhou_et_Zhang_2002a", "Zhou_et_Zhang_2002b", "Zhou_et_Zhang_2005a", "Zhou_et_Zhang_2006a", "Zhou_etal_2008a", "Zhou_etal_2009a", "Zhou_etal_2010a", "Zhou_etal_2012a", "Zhou_etal_2014a") # Archosaurs#
cetaceainclusivedatalist <- c("Aguirre-Fernandez_et_Fordyce_2014a", "Bianucci_2013a", "Bianucci_et_Gingerich_2011a", "Bianucci_et_Landini_2006a", "Bianucci_etal_2007a", "Bianucci_etal_2010a", "Bianucci_etal_2013a", "Bianucci_etal_2016a", "Bisconti_2008a", "Bisconti_2010a", "Bisconti_et_Bosselaers_2016a", "Bisconti_etal_2013a", "Bisconti_inpressa", "Boersma_et_Pyenson_2015a", "Boersma_et_Pyenson_2016a", "Boersma_etal_2017a", "Boessenecker_et_Fordyce_2015a", "Boessenecker_et_Fordyce_2017a", "Boessenecker_et_Fordyce_inpressa", "Bosselaers_et_Post_2010a", "Bouetel_et_de_Muizon_2006a", "Buono_et_Cozzuol_2013a", "Churchill_etal_2012a", "Colpaert_etal_inpressa", "Dooley_etal_2004a", "Ekdale_etal_2011a", "El_Adli_etal_2014a", "Fajardo-Mellor_etal_2006a", "Fitzgerald_2010a", "Fordyce_et_Marx_2013a", "Fordyce_et_Marx_2016a", "Geisler_2001a", "Geisler_et_Luo_1996a", "Geisler_et_Sanders_2003a", "Geisler_et_Uhen_2003a", "Geisler_etal_2005a", "Geisler_etal_2011a", "Geisler_etal_2012a", "Geisler_etal_2014a", "Geisler_etal_2017a", "Godfrey_etal_2016a", "Godfrey_etal_2017a", "Goldin_et_Startsev_2014a", "Goldin_et_Steeman_2015a", "Goldin_et_Zvonok_2013a", "Goldin_etal_inpressa", "Heyning_1997a", "Kimura_et_Hasegawa_2010a", "Lambert_2008a", "Lambert_et_Louwye_2016a", "Lambert_etal_2008a", "Lambert_etal_2009a", "Lambert_etal_2010a", "Lambert_etal_2013a", "Lambert_etal_2014a", "Lambert_etal_2015a", "Lambert_etal_2017a", "Lambert_etal_inpressa", "Lambert_etal_inpressb", "Luo_et_Marsh_1996a", "Marx_2011a", "Marx_et_Fordyce_2015a", "Marx_etal_2016a", "Marx_etal_2017a", "Messenger_et_McGuire_1998a", "Mijan_etal_inpressa", "Murakami_etal_2012a", "Murakami_etal_2012b", "Murakami_etal_2014a", "Murakami_etal_2014b", "Murakami_etal_inpressa", "OLeary_et_Gatesy_2008a", "Peredo_et_Uhen_2016a", "Pyenson_etal_2015a", "Ramassamy_2016a", "Steeman_2007a", "Tanaka_et_Fordyce_2014a", "Tanaka_et_Fordyce_2015a", "Tanaka_et_Fordyce_2016a", "Tanaka_et_Fordyce_inpressa", "Theodor_et_Foss_2005a", "Thewissen_etal_2001a", "Tsai_et_Fordyce_inpressa", "Tsai_et_Fordyce_inpressb", "Uhen_1999a", "Uhen_2004a", "Uhen_et_Gingerich_2001a", "Velez-Juarbe_etal_2015a", "Wichura_etal_inpressa") # If only using select matrices then list them here (default is c(), i.e., NULL) NB: This can speed things up considerably for smaller metatrees as saves time processing the full data base, but could be dangerous if misses key data sets; Cetacea in this example#
temnoinclusivedatalist <- c("Anderson_2001a", "Anderson_2007a", "Anderson_et_Bolt_2013aa", "Anderson_et_Bolt_2013ab", "Anderson_etal_2003a", "Anderson_etal_2008a", "Anderson_etal_2008b", "Berman_etal_2010a", "Berman_etal_2011a", "Bourget_et_Anderson_2011a", "Boy_1989a", "Boy_1990a", "Boy_1993a", "Cisneros_etal_2015b", "Cosgriff_et_Zawiskie_1979a", "Damiani_2001a", "Damiani_et_Kitching_2003a", "Damiani_et_Warren_1996a", "Damiani_et_Yates_2003a", "Damiani_etal_2006a", "Dias-da-Silva_et_Marsicano_2011a", "Dias-da-Silva_etal_2012a", "Dilkes_1990a", "Dilkes_2015a", "Eltink_et_Langer_2014a", "Eltink_etal_2016a", "Eltink_etal_inpressa", "Englehorn_etal_2008a", "Fortuny_etal_2011a", "Fortuny_etal_inpressa", "Frobisch_et_Reisz_2008b", "Frobisch_et_Reisz_2012a", "Frobisch_et_Schoch_2009a", "Germain_2008a", "Germain_2010a", "Glienke_2012a", "Glienke_2015a", "Hammer_1987a", "Holmes_etal_1998a", "Holmes_etal_2013a", "Huttenlocker_etal_2007aa", "Huttenlocker_etal_2007ab", "Huttenlocker_etal_2013a", "Klembara_et_Steyer_2012a", "Laurin_et_Reisz_1997a", "Laurin_et_Reisz_1999a", "Laurin_et_Soler-Gijon_2001a", "Laurin_et_Soler-Gijon_2006aa", "Laurin_et_Soler-Gijon_2006ab", "Liu_2016a", "Liu_et_Wang_2005a", "Maddin_et_Anderson_2012a", "Maddin_etal_2012a", "Maddin_etal_2013aa", "Maddin_etal_2013ab", "Maganuco_et_Pasini_2009a", "Maganuco_etal_2009a", "Marjanovic_et_Laurin_2008aa", "Marjanovic_et_Laurin_2008ab", "Marsicano_1999a", "Marsicano_et_Warren_1998a", "Marsicano_etal_inpressa", "Marzola_etal_2017a", "McGowan_2002a", "Milner_et_Ruta_2009a", "Morales_et_Shishkin_2002a", "Olori_2015aa", "Olori_2015ab", "Pacheco_etal_inpressa", "Pardo_etal_2017a", "Pardo_etal_inpressa", "Pawley_et_Warren_2005a", "Pineiro_etal_2007a", "Pineiro_etal_2012a", "Polley_et_Reisz_2011a", "Ruta_2009a", "Ruta_et_Bolt_2006a", "Ruta_et_Bolt_2008a", "Ruta_et_Coates_2007a", "Ruta_etal_2003a", "Schoch_1997a", "Schoch_2000a", "Schoch_2006a", "Schoch_2008a", "Schoch_2008b", "Schoch_2011a", "Schoch_2012a", "Schoch_2013a", "Schoch_2014a", "Schoch_et_Milner_2004a", "Schoch_et_Milner_2008a", "Schoch_et_Milner_2014a", "Schoch_et_Rubidge_2005a", "Schoch_et_Sues_2013a", "Schoch_et_Witzmann_2009a", "Schoch_et_Witzmann_2009b", "Schoch_etal_2007a", "Sequeira_2003a", "Sidor_etal_2005a", "Sidor_etal_2014a", "Sigurdsen_et_Bolt_2010a", "Sigurdsen_et_Green_2011a", "Steyer_2000aa", "Steyer_2000ab", "Steyer_2000ac", "Steyer_2000ad", "Steyer_2002a", "Steyer_2003a", "Steyer_etal_2006a", "Strapasson_etal_2015a", "Sues_et_Schoch_2013b", "Valin_et_Laurin_2004a", "Warren_et_Marsicano_2000a", "Warren_etal_2011a", "Werneburg_et_Berman_2012a", "Witzmann_2013a", "Witzmann_et_Schoch_2006a", "Witzmann_etal_2016a", "Yates_1999a", "Yates_et_Warren_2000a") # Temnospondyls (including other early amphibians)#
pelycoinclusivedatalist <- c("Romano_et_Nicosia_inpressa", "Benson_2012a", "Brocklehurst_etal_2016a", "Maddin_etal_2008a", "Reisz_et_Frobisch_2014a", "Anderson_et_Reisz_2004a", "Berman_etal_2014a", "Botha-Brink_et_Modesto_2009a", "Campione_et_Reisz_2010a", "Maddin_etal_2006a", "Modesto_etal_2001a", "Reisz_et_Dilkes_2003a", "Reisz_et_Laurin_2004a", "Reisz_etal_1998a", "Reisz_etal_2009a", "Reisz_etal_2010a", "Sumida_etal_2014a", "Amson_et_Laurin_2011aa", "Amson_et_Laurin_2011ab", "Berman_etal_1995a", "Brink_et_Reisz_2014a", "Brink_etal_2015aa", "Brink_etal_2015ab", "Frobisch_etal_2011a", "Kissel_et_Reisz_2004a", "Laurin_1993a", "Liu_etal_2009a", "Mazierski_et_Resiz_2010a", "Modesto_1994a", "Modesto_1995a", "Reisz_etal_1992a", "Sidor_2003a", "Sidor_et_Hopson_1998a", "Spindler_etal_2015a") # Pelycosaurs#
exclusivedatalist <- c("Brocklehurst_etal_2013a", "Brocklehurst_etal_2015aa", "Brocklehurst_etal_2015ab", "Brocklehurst_etal_2015ac", "Brocklehurst_etal_2015ad", "Brocklehurst_etal_2015ae", "Brocklehurst_etal_2015af", "Brusatte_etal_2009ba", "Carr_et_Williamson_2004a", "Garcia_etal_2006a", "Grellet-Tinner_et_Chiappe_2004a", "Grellet-Tinner_et_Makovicky_2006a", "Knoll_2008a", "Kurochkin_1996a", "Pisani_etal_2002a", "Ruiz-Omenaca_etal_1997a", "Ruta_etal_2007a", "Sereno_1993a", "Tsuihiji_etal_2011aa", "Varricchio_et_Jackson_2004a", "Wilson_2005aa", "Wilson_2005ab", "Zelenitsky_et_Therrien_2008a") # If wanting to exclude select matrices then list them here (default is c(), i.e., NULL)#
highertaxatocollapse <- c() # If nested clades within the target clade are not the main focus then list them here and they will be collapsed to a single OTU in the tree (e.g., Mesozoic dinosaurs could target "Dinosauria" but collapse "Neornithes"). Default is c(), i.e., NULL:#
missingspecies <- "genus" # Only species-level OTUs included in phylogenies ("exclude"), replace only genera without species-level OTUs ("genus"), or insert all taxa belonging to target clade ("all")
targetclade = "Cetacea"; inclusivedatalist = cetaceainclusivedatalist
# Print current processing status:#
  cat("Reading MRP data...")#
  # Set working directory as MRP directory:#
  setwd(MRPdirectory)#
  # List MRP files (or just use inslusivedatalist if set):#
  MRPFileList <- strsplit(ifelse(is.null(inclusivedatalist), paste(setdiff(gsub("mrp\\.nex", "", list.files()), exclusivedatalist), "mrp.nex", sep = "", collapse = "%%"), paste(setdiff(inclusivedatalist, exclusivedatalist), "mrp.nex", sep = "", collapse = "%%")), "%%")[[1]]#
  # Create empty MRP list to store MRP matrices:#
  MRPList <- list()#
  # Read in all MRP files and store in a list:#
  for(i in MRPFileList) MRPList[[i]] <- ReadMorphNexus(i)[c("matrix", "header", "header")]#
  # Print current processing status:#
  cat("Done\nReading XML data...")#
  # Set working directory as XML (i.e., metadata) directory:#
  setwd(XMLdirectory)#
  # List MRP files (or just use inslusivedatalist if set):#
  XMLFileList <- strsplit(ifelse(is.null(inclusivedatalist), paste(setdiff(gsub("\\.xml", "", list.files()), exclusivedatalist), ".xml", sep = "", collapse = "%%"), paste(setdiff(inclusivedatalist, exclusivedatalist), ".xml", sep = "", collapse = "%%")), "%%")[[1]]#
  # Check there are no MRPs not listed as XMLs and vice versa (should return empty vector):#
  MRPXMLunion <- c(setdiff(gsub("\\.xml", "", XMLFileList), gsub("mrp\\.nex", "", MRPFileList)), setdiff(gsub("mrp\\.nex", "", MRPFileList), gsub("\\.xml", "", XMLFileList)))#
  # Stop if MRP datasets not listed as XMLs and vice versa:#
  if(length(MRPXMLunion) > 0) stop(paste("Datasets do not match (MRP and XML)!:", MRPXMLunion, collapse = " "))#
  # Update MRP names with stripped down file name:#
  names(MRPList) <- gsub("mrp.nex", "", names(MRPList))#
  # Empty vectors to store error-creating data sets:#
  duplicatedtaxonnames <- namematchissues <- vector(mode = "character")#
  # For each data set:#
  for(i in XMLFileList) {#
    # Get currentfilename:#
    currentfilename <- gsub(".xml", "", i)#
    # Extract XML text:#
    XMLString <- readLines(i)#
    # Extract taxonomic resolution text only:#
    TaxonNoNameMatrix <- matrix(unlist(lapply(strsplit(unlist(lapply(strsplit(XMLString[grep("recon_name", XMLString)], "recon_name=\""), '[', 2)), "\" recon_no=\"|\"|</List>|>"), '[', c(1, 2, 4))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("PaleoDBname", "PaleoDBnumber", "OTUName")))[, c(2, 1, 3)]#
    # Check for spaces in taxon names:#
    if(length(grep(" ", TaxonNoNameMatrix[, "OTUName"])) > 0) stop(paste("Found spaces in taxon names in ", i, ".", collapse = ""))#
    # Check for spaces in taxon numbers:#
    if(length(grep(" ", TaxonNoNameMatrix[, "PaleoDBnumber"])) > 0) stop(paste("Found spaces in taxon numbers in ", i, ".", collapse = ""))#
    # Match OTU names with initial reconciled values:#
    taxonmatches <- match(rownames(MRPList[[currentfilename]]$matrix), TaxonNoNameMatrix[, "OTUName"])#
    # Check everything does match (if not add to match issues vector):#
    if(any(is.na(taxonmatches))) namematchissues <- c(namematchissues, currentfilename)#
    # Check there are not duplicate taxa:#
    if(any(duplicated(sort((taxonmatches))))) duplicatedtaxonnames <- c(duplicatedtaxonnames, currentfilename)#
    # Perform initial reconciliation of matrix names:#
    rownames(MRPList[[currentfilename]]$matrix) <- paste(TaxonNoNameMatrix[taxonmatches, "PaleoDBnumber"], TaxonNoNameMatrix[taxonmatches, "PaleoDBname"], sep = "%%%%")#
    # Extract parent string:#
    ParentString <- gsub("\t|<Parent|Parent>|<|>|/", "", XMLString[grep("<Parent", XMLString)])#
    # Extract sibling string:#
    SiblingString <- gsub("\t|<Sibling|Sibling>|<|>|/", "", XMLString[grep("<Sibling", XMLString)])#
    # Update names of empty headers to their actual use (parent adn sibling strings):#
    names(MRPList[[currentfilename]])[2:3] <- c("parent", "sibling")#
    # Store parent and sibling strings ("" is empty as NULL deletes them from list):#
    MRPList[[currentfilename]][c("parent", "sibling")] <- c(ParentString, SiblingString)#
  }#
  # Stop and return braces issue (or non-matching taxa issue):#
  if(length(namematchissues) > 0) stop(paste(paste("Possible missing braces (<>), rogue period(s) (.), or non-matching taxon names in ", namematchissues, " XML file.", sep = ""), collapse = "\n"))#
  # Stop and return duplicated OTU name matrices (if any):#
  if(length(duplicatedtaxonnames) > 0) stop(paste(paste("Possible duplicated taxa in ", duplicatedtaxonnames, " XML file.", sep = ""), collapse = "\n"))#
  # Print current processing status:#
  cat("Done\nFinding initial multiple-taxon reconciliations...")#
  # For each data set:#
  for(i in names(MRPList)) {#
    # Find comma rows (multiple taxa in initial reconciliation):#
    commarows <- grep(",", rownames(MRPList[[i]]$matrix))#
    # If there is at least one multiple-taxon reconciliation:#
    if(length(commarows) > 0) {#
      # For each multiple-taxon reconciliation in reverse order (to avoid later rows not matching):#
      for(j in rev(commarows)) {#
        # Get multiple names of reconciliation:#
        multiplenames <- strsplit(rownames(MRPList[[i]]$matrix)[j], "%%%%")[[1]]#
        # Get multiple-taxon numbers:#
        multitaxonnumbers <- strsplit(multiplenames[1], ";")[[1]]#
        # Get multiple-taxon names:#
        multitaxonnames <- strsplit(multiplenames[2], ",")[[1]]#
        # Check data intergirty with respect to multiple-taxon values:#
        if(length(multitaxonnumbers) != length(multitaxonnames)) stop(paste("Problem with multiple-taxon reconciliation(s) in ", i, " (check commas and semi-colons are correct).", sep = ""))#
        # Add new rows at base of matrix:#
        MRPList[[i]]$matrix <- rbind(MRPList[[i]]$matrix, matrix(rep(MRPList[[i]]$matrix[j, ], length(multitaxonnumbers)), nrow = length(multitaxonnumbers), byrow = TRUE, dimnames = list(paste(multitaxonnumbers, multitaxonnames, sep = "%%%%"), c())))#
        # Remove now redundnat row from matrix:#
        MRPList[[i]]$matrix <- MRPList[[i]]$matrix[-j, ]#
      }#
    }#
  }#
  # Print current processing status:#
  cat("Done\nRemoving taxa with initial reconciliations of \"DELETE\"...")#
  # For each data set:#
  for(i in names(MRPList)) {#
    # Find delete rows (initial ones - may remove some later through:#
    deleterows <- which(matrix(unlist(strsplit(rownames(MRPList[[i]]$matrix), "%%%%")), ncol = 2, byrow = TRUE)[, 2] == "DELETE")#
    # If there are deletes:#
    if(length(deleterows) > 0) {#
      # Remove deleted taxon rows:#
      MRPList[[i]]$matrix <- MRPList[[i]]$matrix[-deleterows, , drop = FALSE]#
      # If less than three taxa then just delete all columns (characters) too:#
      if(nrow(MRPList[[i]]$matrix) < 3) MRPList[[i]]$matrix <- MRPList[[i]]$matrix[, -c(1:ncol(MRPList[[i]]$matrix)), drop = FALSE]#
    }#
  }#
  # Print current processing status:#
  cat("Done\nSearching for and collapsing pre-reconciliation duplicated taxa...")#
  # Create empty vector to store data sets with duplicated initially reconciled OTU names:#
  duplicatedresolvedOTUs <- vector(mode = "character")#
  # For each data set:#
  for(i in names(MRPList)) {#
    # Case if any (initially) resolved names are non-unique:#
    if(any(duplicated(sort(rownames(MRPList[[i]]$matrix))))) {#
      # Get duplicated taxon name(s):#
      duplicatedtaxa <- unique(sort(rownames(MRPList[[i]]$matrix))[duplicated(sort(rownames(MRPList[[i]]$matrix)))])#
      # For each duplicated taxon:#
      for(j in duplicatedtaxa) {#
        # Get rows for taxon:#
        duplicaterows <- which(rownames(MRPList[[i]]$matrix) == j)#
        # Build duplicated matrix from other taxa:#
        tempMRPmatrix <- matrix(rep(MRPList[[i]]$matrix[-duplicaterows, ], length(duplicaterows)), ncol = ncol(MRPList[[i]]$matrix) * length(duplicaterows), dimnames = list(rownames(MRPList[[i]]$matrix)[-duplicaterows], c()))#
        # Add duplicated taxon as single row:#
        tempMRPmatrix <- rbind(tempMRPmatrix, as.vector(t(MRPList[[i]]$matrix[duplicaterows, ])))#
        # Add duplicated taxon name:#
        rownames(tempMRPmatrix)[nrow(tempMRPmatrix)] <- j#
        # Update stored MRP matrix:#
        MRPList[[i]]$matrix <- tempMRPmatrix#
      }#
      # Collapse to just unique characters (has to be outside the above or breaks if more than one duplicate taxon):#
      MRPList[[i]]$matrix <- MRPCollapse(MakeMorphMatrix(MRPList[[i]]$matrix, header = "", weights = rep(1, ncol(MRPList[[i]]$matrix)), ordering = rep("unord", ncol(MRPList[[i]]$matrix)), equalise.weights = FALSE))$matrix#
      # Store duplicated OTU names:#
      duplicatedresolvedOTUs <- c(duplicatedresolvedOTUs, paste("Duplicated resolved OTUs (", paste(unlist(lapply(strsplit(duplicatedtaxa, "%%%%"), '[', 2)), collapse = ", "), ") in: ", i, ".\n", sep = ""))#
    }#
    # Format MRP as NEXUS type matrix:#
    MRPmatrix <- MakeMorphMatrix(MRPList[[i]]$matrix, header = "", weights = rep(1, ncol(MRPList[[i]]$matrix)), ordering = rep("unord", ncol(MRPList[[i]]$matrix)), equalise.weights = FALSE)#
    # Collapse MRP matrix (removes redundant characters created by taxon deletions):#
    MRPList[[i]]$matrix <- MRPCollapse(MRPmatrix)$matrix#
  }#
  # Warn user if there are initially duplicated reconciled taxa (user should check):#
  if(length(duplicatedresolvedOTUs) > 0) cat(paste(duplicatedresolvedOTUs, collapse = ""))#
  # Print current processing status:#
  cat("Done\nBuilding initial taxonomy matrix...")#
  # Create taxonomy matrix to store all taxon resolution data:#
  TaxonomyMatrix <- matrix(unlist(strsplit(sort(unique(unlist(lapply(lapply(MRPList, '[[', 1), rownames)))), "%%%%")), ncol = 2, byrow = TRUE, dimnames = list(c(), c("TaxonNo", "TaxonName")))#
  # Print current processing status:#
  cat("Done\nBuilding initial Paleobiology Database reconciliation list...")#
  # Create empty matrix to store taxonomic reconciliations:#
  resolvedtaxonnumbers <- matrix(nrow = 0, ncol = 9, dimnames = list(c(), c("InputNo", "OriginalTaxonNo", "ResolvedTaxonNo", "TaxonName", "TaxonRank", "ParentTaxonNo", "TaxonValidity", "AcceptedNumber", "AcceptedName")))#
  # For each unique PaleobioDB taxon number:#
  for(i in unique(unlist(strsplit(TaxonomyMatrix[, "TaxonNo"], "&")))) {#
    # Reconcile and store:#
    resolvedtaxonnumbers <- rbind(resolvedtaxonnumbers, c(i, unlist(PaleobiologyDBTaxonQuerier(i))))#
    # Wait to avoid overloading database with queries:#
    Sys.sleep(waittime)#
  }#
  # Print current processing status:#
  cat("Done\nChecking taxon names match with database version...")#
  # For each initially reconciled name:#
  for(i in 1:nrow(TaxonomyMatrix)) {#
    # Get resolved name:#
    resolvedname <- gsub(" ", "_", resolvedtaxonnumbers[which(resolvedtaxonnumbers[, "InputNo"] == TaxonomyMatrix[i, "TaxonNo"]), "TaxonName"])#
    # Get input name:#
    inputname <- TaxonomyMatrix[i, "TaxonName"]#
    # Check names truly match (i.e., deals with case of indets where direct match not possible):#
    if(resolvedname != inputname && any(is.na(match(strsplit(resolvedname, "_")[[1]], strsplit(inputname, "_")[[1]])))) stop(paste("Input name ", inputname, " does not match database name for corresponding number (", resolvedname, ").", sep = ""))#
  }#
  # Print current processing status:#
  cat("Done\nChecking taxon validities...")#
  # List of types of resolution that require finding a senior synonym:#
  synonyms <- c("corrected to", "misspelling of", "objective synonym of", "obsolete variant of", "recombined as", "replaced by", "subjective synonym of")#
  # List of types of resolution that require changing reconciliation to DELETE:#
  deletes <- c("nomen dubium", "nomen vanum", "nomen nudum", "nomen oblitum", "invalid subgroup of")#
  # Check for any new kind of resolution (should be empty vector):#
  newresolutions <- setdiff(sort(unique(resolvedtaxonnumbers[, "TaxonValidity"])), c(deletes, synonyms))#
  # Stop if new resolutiosn found (need to add these to the resolution types above):#
  if(length(newresolutions) > 0) stop(paste("New resolution type found!: ", newresolutions, sep = ""))#
  # Print current processing status:#
  cat("Done\nBuilding synonymy tables...")#
  # Empty vector to store rows that correspond to some form of junior synonym:#
  synonymrows <- c()#
  # Find all junior synonym rows:#
  for(i in synonyms) synonymrows <- sort(c(synonymrows, which(resolvedtaxonnumbers[, "TaxonValidity"] == i)))#
  # Set junior synonym matrix:#
  juniorsynonyms <- resolvedtaxonnumbers[synonymrows, ]#
  # Create empty matrix to store senior synoyms:#
  seniorsynonyms <- matrix(nrow = 0, ncol = 8, dimnames = list(c(), c("OriginalTaxonNo", "ResolvedTaxonNo", "TaxonName", "TaxonRank", "ParentTaxonNo", "TaxonValidity", "AcceptedNumber", "AcceptedName")))#
  # For each potential synonym:#
  for(i in synonymrows) {#
    # Reconcile senior synonym with database:#
    currenttaxon <- PaleobiologyDBTaxonQuerier(gsub("txn:", "", resolvedtaxonnumbers[i, "AcceptedNumber"]), )#
    # While senior synonym is itself invalid:#
    while(!is.na(currenttaxon$TaxonValidity)) {#
      # Check case where resolved and accepted numbers could lead to infinite loop:#
      while(!is.na(currenttaxon$AcceptedNumber) && currenttaxon$ResolvedTaxonNo == currenttaxon$AcceptedNumber) {#
        # Update current taxon resolution using accepted name instead of number:#
        currenttaxon <- PaleobiologyDBTaxonQuerier(taxon_no = "1", taxon_name = currenttaxon$AcceptedName)#
        # Wait to avoid overloading database:#
        Sys.sleep(waittime)#
      }#
      # While the resolved taxon is itself still a synonym:#
      while(!is.na(currenttaxon$AcceptedNumber)) {#
        # Update current taxon resolution:#
        currenttaxon <- PaleobiologyDBTaxonQuerier(gsub("txn:", "", currenttaxon$AcceptedNumber))#
        # Wait to avoid overloading database:#
        Sys.sleep(waittime)#
      }#
    }#
    # Add final resolution to senior synonyms list:#
    seniorsynonyms <- rbind(seniorsynonyms, unlist(currenttaxon))#
    # To avoid overloading the database wait:#
    Sys.sleep(waittime)#
  }#
  # Print current processing status:#
  cat("Done\nChecking validity of indeterminate taxon reconciliations...")#
  # Get list of indeterminates:#
  indeterminates <- TaxonomyMatrix[which((unlist(lapply(lapply(strsplit(TaxonomyMatrix[, "TaxonName"], "_"), '==', "aff"), sum)) + unlist(lapply(lapply(strsplit(TaxonomyMatrix[, "TaxonName"], "_"), '==', "cf"), sum)) + unlist(lapply(lapply(strsplit(TaxonomyMatrix[, "TaxonName"], "_"), '==', "indet"), sum)) + unlist(lapply(lapply(strsplit(TaxonomyMatrix[, "TaxonName"], "_"), '==', "sp"), sum))) > 0), "TaxonName"]#
  # For each indeterminate:#
  for(i in indeterminates) {#
    # Get resolved row number:#
    resolvedrownumber <- which(resolvedtaxonnumbers[, "InputNo"] == TaxonomyMatrix[which(TaxonomyMatrix[, "TaxonName"] == i), "TaxonNo"])#
    # If resolution is invalid stop and warn user to consider changing name:#
    if(!is.na(resolvedtaxonnumbers[resolvedrownumber, "TaxonValidity"])) stop(paste(i, " assigned to a taxon that is invalid, consider renaming.", sep = ""))#
  }#
  # Print current processing status:#
  cat("Done\nDeleting taxa resolved as nomen dubium and the like...")#
  # Empty vector to store rows that correspond to some form of junior synonym:#
  deleterows <- c()#
  # Find all junior synonym rows:#
  for(i in deletes) deleterows <- sort(c(deleterows, which(resolvedtaxonnumbers[, "TaxonValidity"] == i)))#
  # Get input numbers that should be deleted:#
  numberstodelete <- resolvedtaxonnumbers[deleterows, "InputNo"]#
  # Create list of taxon numbers to check for data sets with DELETE resolutions:#
  taxonnumberslist <- lapply(lapply(lapply(lapply(lapply(lapply(lapply(lapply(MRPList[which(unlist(lapply(lapply(lapply(MRPList, '[[', 1), rownames), length)) > 0)], '[[', 1), rownames), strsplit, split = "%%%%"), unlist), matrix, ncol = 2, byrow = TRUE), '[', ,1), strsplit, split = "&"), unlist)#
  # Create empty vector to store datasets with deletes (that cna then be processed):#
  datasetswithdeletes <- vector(mode = "character")#
  # For each delete number find data sets that have it and add them to the vector:#
  for(i in numberstodelete) datasetswithdeletes <- sort(unique(c(datasetswithdeletes, names(which(unlist(lapply(lapply(taxonnumberslist, '==', i), sum)) > 0)))))#
  # For each dataset with at least one taxon to delete:#
  for(i in datasetswithdeletes) {#
    # Isolate taxon numbers for current dataset:#
    taxonnumbers <- unlist(lapply(strsplit(rownames(MRPList[[i]]$matrix), "%%%%"), '[', 1))#
    # Convert into list to deal with multi-number higher taxa:#
    taxonnumbers <- lapply(lapply(as.list(taxonnumbers), strsplit, split = "&"), unlist)#
    # Create empty vector to store taxa to delete:#
    taxatodelete <- vector(mode = "numeric")#
    # Find any taxa to delete present in the data set:#
    for(j in numberstodelete) taxatodelete <- sort(unique(c(taxatodelete, which(unlist(lapply(lapply(taxonnumbers, '==', j), any))))))#
    # Find any multi-number higher taxa that are listed as deletes:#
    multinumberhighertaxatodelete <- taxatodelete[which(unlist(lapply(taxonnumbers[taxatodelete], length)) > 1)]#
    # Stop if you find a multi-number higher taxon that is (at least partially) to be deleted):#
    if(length(multinumberhighertaxatodelete) > 0) stop(paste("Multi-number higher tax(a) listed to delete: ", paste(unlist(lapply(strsplit(rownames(MRPList[[i]]$matrix), "%%%%"), '[', 2))[multinumberhighertaxatodelete], sep = ","), " (NB: check the status of these).", sep = ""))#
    # Create MRP matrix:#
    MRPmatrix <- MakeMorphMatrix(MRPList[[i]]$matrix[-taxatodelete, , drop = FALSE], header = "", weights = rep(1, ncol(MRPList[[i]]$matrix[-taxatodelete, , drop = FALSE])), ordering = rep("unord", ncol(MRPList[[i]]$matrix[-taxatodelete, , drop = FALSE])), equalise.weights = FALSE)#
    # Overwrite matrix with collapsed version following taxon deletions:#
    MRPList[[i]]$matrix <- MRPCollapse(MRPmatrix)$matrix#
  }#
  # Print current processing status:#
  cat("Done\nReplacing junior synonyms with senior synonyms...")#
  # Get input numbers that should be replaced:#
  numberstosynonymise <- juniorsynonyms[, "InputNo"]#
  # Create empty vector to store datasets with deletes (that cna then be processed):#
  datasetswithjuniorsynonyms <- vector(mode = "character")#
  # For each delete number find data sets that have it and add them to the vector:#
  for(i in numberstosynonymise) datasetswithjuniorsynonyms <- sort(unique(c(datasetswithjuniorsynonyms, names(which(unlist(lapply(lapply(taxonnumberslist, '==', i), sum)) > 0)))))#
  # For each dataset with at least one taxon to delete:#
  for(i in datasetswithjuniorsynonyms) {#
    # Isolate taxon numbers for current dataset:#
    taxonnumbers <- unlist(lapply(strsplit(rownames(MRPList[[i]]$matrix), "%%%%"), '[', 1))#
    # Convert into list to deal with multi-number higher taxa:#
    taxonnumbers <- lapply(lapply(as.list(taxonnumbers), strsplit, split = "&"), unlist)#
    # Create empty vector to store taxa to synonymise:#
    taxatosynonymise <- vector(mode = "numeric")#
    # Find any taxa to synonymise present in the data set:#
    for(j in numberstosynonymise) taxatosynonymise <- sort(unique(c(taxatosynonymise, which(unlist(lapply(lapply(taxonnumbers, '==', j), any))))))#
    # Find any multi-number higher taxa to synonymise:#
    multinumberhighertaxontosynonymise <- unlist(lapply(strsplit(rownames(MRPList[[i]]$matrix), "%%%%"), '[', 2))[taxatosynonymise[which(unlist(lapply(taxonnumbers[taxatosynonymise], length)) > 1)]]#
    # Stop if you find a multi-number higher taxon that is (at least partially) to be deleted):#
    if(length(multinumberhighertaxontosynonymise) > 0) stop(paste("Multi-number higher tax(a) listed to synonymise: ", paste(multinumberhighertaxontosynonymise, sep = ","), " (NB: check the status of these).", sep = ""))#
    # For each taxon to synonymise:#
    for(j in taxatosynonymise) {#
      # Find corresponding row number in senior synonyms list:#
      seniorrownumber <- which(juniorsynonyms[, "InputNo"] == strsplit(rownames(MRPList[[i]]$matrix)[j], "%%%%")[[1]][1])#
      # Overwrite junior with senior synonym:#
      rownames(MRPList[[i]]$matrix)[j] <- paste(gsub("txn:|var:", "", rev(sort(seniorsynonyms[seniorrownumber, c("OriginalTaxonNo", "ResolvedTaxonNo")]))[1]), gsub(" ", "_", seniorsynonyms[seniorrownumber, "TaxonName"]), sep = "%%%%")#
    }#
  }#
  # Print current processing status:#
  cat("Done\nChecking for orphan taxa...")#
  # Find orphans:#
  orphans <- sort(unique(c(resolvedtaxonnumbers[which(is.na(resolvedtaxonnumbers[, "ParentTaxonNo"])), "TaxonName"], seniorsynonyms[which(is.na(seniorsynonyms[, "ParentTaxonNo"])), "TaxonName"])))#
  # If orphans warn user to fix them:#
  if(length(orphans) > 0) stop(paste("Fix the following orphan taxa: ", paste(orphans, sep = ", "), ".", sep = ""))#
  # Print current processing status:#
  cat("Done\nBuilding taxonomy...")#
  # Get a list of the valid OTU names (may be pruned down later to just those in target clade):#
  ValidOTUNames <- unique(unlist(lapply(lapply(MRPList, '[[', 1), rownames)))[grep("_", unique(unlist(lapply(lapply(MRPList, '[[', 1), rownames))))]#
  # Replace junior with senior synonyms in resolved names matrix:#
  resolvedtaxonnumbers[synonymrows, c("OriginalTaxonNo", "ResolvedTaxonNo", "TaxonName", "TaxonRank", "ParentTaxonNo", "TaxonValidity", "AcceptedNumber", "AcceptedName")] <- seniorsynonyms#
  # Overwrite resolved number with resolved taxon number:#
  resolvedtaxonnumbers[, "ResolvedTaxonNo"] <- gsub("txn:|var:", "", unlist(lapply(lapply(apply(resolvedtaxonnumbers[, c("OriginalTaxonNo", "ResolvedTaxonNo")], 1, sort), rev), '[', 1)))#
  # Remove original taxon number column:#
  resolvedtaxonnumbers <- resolvedtaxonnumbers[, -which(colnames(resolvedtaxonnumbers) == "OriginalTaxonNo")]#
  # Remove deleted taxa from resolved names matrix:#
  resolvedtaxonnumbers <- resolvedtaxonnumbers[-which(!is.na(resolvedtaxonnumbers[, "TaxonValidity"])), ]#
  # Reformat parent taxon numbers into just numbers:#
  resolvedtaxonnumbers[, "ParentTaxonNo"] <- gsub("txn:", "", resolvedtaxonnumbers[, "ParentTaxonNo"])#
  # Collapse resolved matrix to just field with values (i.e., drop valid and senior synonym columns):#
  resolvedtaxonnumbers <- resolvedtaxonnumbers[, c("ResolvedTaxonNo", "TaxonName", "TaxonRank", "ParentTaxonNo")]#
  # If doing something with missing species (i.e., those not currently included as OTUs, but existing in target clade):#
  if(missingspecies != "exclude") {#
    # Find all children of target clade:#
    AllChildren <- PaleobiologyDBChildrenFinder(taxon_no = "1", taxon_name = targetclade)#
    # If inserting all missing species get all possible species parent numbers:#
    if(missingspecies == "all") CurrentSpeciesParentNumbers <- unique(c(gsub("txn:", "", AllChildren[, "ParentTaxonNo"]), resolvedtaxonnumbers[which(resolvedtaxonnumbers[, "TaxonRank"] == 3), "ParentTaxonNo"]))#
    # If only inserting missing species at genus-level find parent numbers of all current species (i.e., potential genera to add):#
    if(missingspecies == "genus") CurrentSpeciesParentNumbers <- unique(resolvedtaxonnumbers[which(resolvedtaxonnumbers[, "TaxonRank"] == 3), "ParentTaxonNo"])#
    # Find any parents not already present in resolved numbers matrix:#
    AsYetUnsampledSpeciesParents <- setdiff(CurrentSpeciesParentNumbers, resolvedtaxonnumbers[, "ResolvedTaxonNo"])#
    # If such parents exist:#
    if(length(AsYetUnsampledSpeciesParents) > 0) {#
      # For each possible parent (genus):#
      for(i in AsYetUnsampledSpeciesParents) {#
        # Resolve parent number:#
        CurrentSpeciesParent <- PaleobiologyDBTaxonQuerier(taxon_no = i)#
        # If a valid genus:#
        if(is.na(CurrentSpeciesParent$TaxonValidity) && CurrentSpeciesParent$TaxonRank == "5") {#
          # Get resolved taxon number:#
          ResolvedNumber <- gsub("txn:|var:", "", sort(unlist(CurrentSpeciesParent[c("OriginalTaxonNo", "ResolvedTaxonNo")]), decreasing = TRUE))#
          # Add to resolved numbers matrix:#
          resolvedtaxonnumbers <- rbind(resolvedtaxonnumbers, c(ResolvedNumber, CurrentSpeciesParent$TaxonName, CurrentSpeciesParent$TaxonRank, gsub("txn:", "", CurrentSpeciesParent$ParentTaxonNo)))#
        }#
      }#
    }#
    # If including all species:#
    if(missingspecies == "all") {#
      # Update Valid OTUs accordingly#
      ValidOTUNames <- unique(c(ValidOTUNames, gsub(" ", "_", paste(unlist(lapply(strsplit(gsub("NA", "", paste(AllChildren[, "OriginalTaxonNo"], AllChildren[, "ResolvedTaxonNo"], sep = "")), split = "var:|txn:"), '[[', 2)), AllChildren[, "TaxonName"], sep = "%%%%"))))#
      # Set new children to add to resolved taxon numbers later:#
      NewChildren <- matrix(c(gsub("txn:|var:", "", unlist(lapply(apply(AllChildren[, c("OriginalTaxonNo", "ResolvedTaxonNo")], 1, sort, decreasing = TRUE), '[', 1))), AllChildren[, c("TaxonName", "TaxonRank")], gsub("txn:", "", AllChildren[, "ParentTaxonNo"])), ncol = 4)#
#
    }#
    # If including only species assigned to genus-level OTUs:#
    if(missingspecies == "genus") {#
      # Get current genus numbers (to check what has already been included):#
      CurrentGenusNumbers <- resolvedtaxonnumbers[which(resolvedtaxonnumbers[, "TaxonRank"] == 5), "ResolvedTaxonNo"]#
      # Get children of first genus:#
      GeneraChildren <- PaleobiologyDBChildrenFinder(taxon_no = CurrentGenusNumbers[1])#
      # If there is more than one genus (pretty likely, but just in case) find children for all other genera:#
      if(length(CurrentGenusNumbers) > 1) for(i in CurrentGenusNumbers[2:length(CurrentGenusNumbers)]) GeneraChildren <- rbind(GeneraChildren, PaleobiologyDBChildrenFinder(taxon_no = i))#
      # Update valid OTUs with children of all sampled genera:#
      ValidOTUNames <- unique(c(ValidOTUNames, gsub(" ", "_", paste(unlist(lapply(strsplit(gsub("NA", "", paste(GeneraChildren[, "OriginalTaxonNo"], GeneraChildren[, "ResolvedTaxonNo"], sep = "")), split = "var:|txn:"), '[[', 2)), GeneraChildren[, "TaxonName"], sep = "%%%%"))))#
      # Set new children to add to resolved taxon numbers later:#
      NewChildren <- matrix(c(gsub("txn:|var:", "", unlist(lapply(apply(GeneraChildren[, c("OriginalTaxonNo", "ResolvedTaxonNo")], 1, sort, decreasing = TRUE), '[', 1))), GeneraChildren[, c("TaxonName", "TaxonRank")], gsub("txn:", "", GeneraChildren[, "ParentTaxonNo"])), ncol = 4)#
    }#
    # Find an new children not already included in resolved taxon numbers list:#
    ChildrenToAdd <- setdiff(NewChildren[, 1], resolvedtaxonnumbers[, "ResolvedTaxonNo"])#
    # If there are children to add then add them to resolved taxon numbers:#
    if(length(ChildrenToAdd) > 0) resolvedtaxonnumbers <- rbind(resolvedtaxonnumbers, NewChildren[match(ChildrenToAdd, NewChildren[, 1]), ])#
  }#
  # Get initial parent child relationships based on OTUs:#
  parentchildrelationships <- paste(unlist(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 1)), resolvedtaxonnumbers[match(unlist(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 1)), resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "ParentTaxonNo"], sep = " belongs to ")#
  # Find which rows correspond to indeterminate and sp taxa (i.e., those where parent should be initial reconciliation):#
  indetsandsps <- sort(c(which(unlist(lapply(lapply(lapply(lapply(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 2), strsplit, split = "_"), unlist), '==', "indet"), any))), which(unlist(lapply(lapply(lapply(lapply(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 2), strsplit, split = "_"), unlist), '==', "sp"), any)))))#
  # If such taxa exist then update parent child relationships accordingly:#
  if(length(indetsandsps) > 0) parentchildrelationships[indetsandsps] <- paste(unlist(lapply(strsplit(ValidOTUNames[indetsandsps], "%%%%"), '[', 1)), unlist(lapply(strsplit(ValidOTUNames[indetsandsps], "%%%%"), '[', 1)), sep = " belongs to ")#
  # Get list of new children (for which parents are needed) - excludes "life" which has no parent:#
  newchildren <- setdiff(unlist(lapply(strsplit(parentchildrelationships, " belongs to "), '[', 2)), "28595")#
  # As long as there are still children in need of parents:#
  while(length(newchildren) > 0) {#
    # Find any numbers missing for the taxonomy name resolution matrix:#
    missingfromresolutions <- newchildren[which(is.na(match(newchildren, resolvedtaxonnumbers[, "ResolvedTaxonNo"])))]#
    # If there are such numbers:#
    if(length(missingfromresolutions) > 0) {#
      # For each missing number:#
      for(i in unique(missingfromresolutions)) {#
        # Get raw query data for new name#
        rawquery <- unlist(PaleobiologyDBTaxonQuerier(i))#
        # Add formatted results of query to resolved names matrix:#
        resolvedtaxonnumbers <- rbind(resolvedtaxonnumbers, c(gsub("txn:|rev:", "", rev(sort(rawquery[c("OriginalTaxonNo", "ResolvedTaxonNo")]))[1]), rawquery["TaxonName"], rawquery["TaxonRank"], gsub("txn:", "", rawquery["ParentTaxonNo"])))#
        # Wait to avoid overloading the database:#
        Sys.sleep(waittime)#
      }#
    }#
    # Add new parent child relationships to list:#
    parentchildrelationships <- c(parentchildrelationships, paste(resolvedtaxonnumbers[match(newchildren, resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "ResolvedTaxonNo"], resolvedtaxonnumbers[match(newchildren, resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "ParentTaxonNo"], sep = " belongs to "))#
    # Update new children:#
    newchildren <- setdiff(resolvedtaxonnumbers[match(newchildren, resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "ParentTaxonNo"], "28595")#
  }#
  # Convert parent-child relationships into a matrix (columns for child and parent):#
  parentchildmatrix <- matrix(unlist(strsplit(parentchildrelationships, split = " belongs to ")), ncol = 2, byrow = TRUE, dimnames = list(c(), c("Child", "Parent")))#
  # Update parent-child matrix with child names:#
  parentchildmatrix[, "Child"] <- resolvedtaxonnumbers[match(parentchildmatrix[, "Child"], resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "TaxonName"]#
  # Update parent-child matrix with parent names:#
  parentchildmatrix[, "Parent"] <- resolvedtaxonnumbers[match(parentchildmatrix[, "Parent"], resolvedtaxonnumbers[, "ResolvedTaxonNo"]), "TaxonName"]#
  # Add valid OTU names into parent-child matrix:#
  parentchildmatrix[c(1:length(ValidOTUNames)), "Child"] <- unlist(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 2))#
  # Add missing taxon ("Life") to parent-child matrix:#
  parentchildmatrix[which(is.na(parentchildmatrix[, "Parent"])), "Parent"] <- "Life"#
  # Create empty taxonomy MRP matrix:#
  TaxonomyMRP <- matrix(0, nrow = length(ValidOTUNames), ncol = length(sort(unique(parentchildmatrix[, "Parent"]))), dimnames = list(sort(unlist(lapply(strsplit(ValidOTUNames, "%%%%"), '[', 2))), sort(unique(parentchildmatrix[, "Parent"]))))#
  # Remove duplicates:#
  parentchildmatrix <- matrix(unlist(strsplit(unique(paste(parentchildmatrix[, "Child"], parentchildmatrix[, "Parent"], sep = "%%%%")), "%%%%")), ncol = 2, byrow = TRUE, dimnames = list(c(), c("Child", "Parent")))#
  # For each OTU (traces up through hierarchy until its presence in every higher taxon to which it belongs is assigned)::#
  for(i in 1:length(ValidOTUNames)) {#
    # Set starting current child taxon:#
    currentchild <- parentchildmatrix[i, "Child"]#
    # Set starting current parent taxon:#
    currentparent <- setdiff(parentchildmatrix[which(parentchildmatrix[, "Child"] == currentchild), "Parent"], currentchild)#
    # Record presence of child in parent in taxonomy matrix:#
    TaxonomyMRP[parentchildmatrix[i, "Child"], currentparent] <- 1#
    # As long as the parent is not "Life" (top of taxonomic hierarchy not reached):#
    while(currentparent != "Life") {#
      # Update child with previous parent:#
      currentchild <- currentparent#
      # Update parent with new parent:#
      currentparent <- setdiff(parentchildmatrix[which(parentchildmatrix[, "Child"] == currentchild), "Parent"], currentchild)#
      # Record presence of child in parent:#
      TaxonomyMRP[parentchildmatrix[i, "Child"], currentparent] <- 1#
    }#
  }#
  # Print current processing status:#
  cat("Done\nTidying up taxonomy...")#
  # Find any subgenera names:#
  subgenerarows <- grep("\\(", colnames(TaxonomyMRP))#
  # If subgenera found make these single names (i.e., removes parentheses that will screw up Newick trees later):#
  if(length(subgenerarows) > 0) colnames(TaxonomyMRP)[subgenerarows] <- unlist(lapply(strsplit(colnames(TaxonomyMRP)[subgenerarows], "\\(|\\)"), '[', 2))#
  # Check target clade is actually found:#
  if(length(which(colnames(TaxonomyMRP) == targetclade)) == 0) stop("Target clade not found in taxonomy. Check spelling/Paleobiology database validity.")#
  # Work out which taxa are actually valid OTUs (belong to target clade):#
  NewValidOTUs <- names(which(TaxonomyMRP[, targetclade] == 1))#
  # Can now strip out numbers from taxon names:#
  for(i in 1:length(MRPList)) if(!is.null(rownames(MRPList[[i]]$matrix))) rownames(MRPList[[i]]$matrix) <- unlist(lapply(strsplit(rownames(MRPList[[i]]$matrix), "%%%%"), '[', 2))#
  # Collapse taxonomy MRP to just new valid taxa:#
  TaxonomyMRP <- TaxonomyMRP[NewValidOTUs, ]#
  # Make taxonomy MRP into list:#
  TaxonomyMRPlist <- split(TaxonomyMRP, rep(1:ncol(TaxonomyMRP), each = nrow(TaxonomyMRP)))#
  # Add column names to list:#
  names(TaxonomyMRPlist) <- colnames(TaxonomyMRP)#
  # Find higher taxa for which every taxon is present:#
  redundanthighertaxa <- colnames(TaxonomyMRP)[intersect(which(unlist(lapply(lapply(TaxonomyMRPlist, unique), length)) == 1), which(unlist(lapply(lapply(TaxonomyMRPlist, unique), '[', 1)) == 1))]#
  # Empty higher taxa:#
  emptyhighertaxa <- colnames(TaxonomyMRP)[intersect(which(unlist(lapply(lapply(TaxonomyMRPlist, unique), length)) == 1), which(unlist(lapply(lapply(TaxonomyMRPlist, unique), '[', 1)) == 0))]#
  # Find taxonomic autapomorphies (those with just one OTU and hence redundant):#
  taxonomicautapomorphies <- names(which(unlist(lapply(TaxonomyMRPlist, sum)) == 1))#
  # Collapse taxonomy MRP by removing constant characters (i.e., most of the subgroups just established - not autapomorphies as they can be substitutes later!):#
  TaxonomyMRP <- TaxonomyMRP[, -match(c(redundanthighertaxa, emptyhighertaxa), colnames(TaxonomyMRP)), drop = FALSE]#
  # Print current processing status:#
  cat("Done\nSubstituting valid OTUs for supraspecific taxa...")#
  # Find datasets with (valid) surpaspceific OTUs:#
  datasetswithsupraspecificOTUs <- which(unlist(lapply(lapply(lapply(lapply(MRPList, '[[', 1), rownames), intersect, y = colnames(TaxonomyMRP)), length)) > 0)#
  # If such data sets exist:#
  if(length(datasetswithsupraspecificOTUs)) {#
    # For each such data set:#
    for(i in datasetswithsupraspecificOTUs) {#
      # Find higher taxa that will need to be replaced:#
      highertaxatoreplace <- intersect(rownames(MRPList[[i]]$matrix), colnames(TaxonomyMRP))#
      # For each higher taxaon to replace:#
      for(j in highertaxatoreplace) {#
        # Find substitue names from taxonomy:#
        substitutenames <- names(which(TaxonomyMRP[, j] == 1))#
        # Add these to end of matrix using coding for higher taxon:#
        MRPList[[i]]$matrix <- rbind(MRPList[[i]]$matrix, matrix(rep(MRPList[[i]]$matrix[j, ], length(substitutenames)), nrow = length(substitutenames), byrow = TRUE, dimnames = list(substitutenames, c())))#
        # Remove now replaced higehr taxon from matrix:#
        MRPList[[i]]$matrix <- MRPList[[i]]$matrix[-which(rownames(MRPList[[i]]$matrix) == j), ]#
      }#
    }#
  }#
  # Print current processing status:#
  cat("Done\nFurther tidying of taxonomy...")#
  # Collapse taxonomy MRP by removing autapomorphic characters (if any):#
  if(length(taxonomicautapomorphies) > 0) TaxonomyMRP <- TaxonomyMRP[, -match(taxonomicautapomorphies, colnames(TaxonomyMRP)), drop = FALSE]#
  # Overwrite taxonomy MRP list with strings for each column:#
  TaxonomyMRPlist <- apply(TaxonomyMRP, 2, paste, collapse = "")#
  # Find any duplicated MRP strings:#
  duplicatedMRPstrings <- rle(sort(TaxonomyMRPlist))$values[which(rle(sort(TaxonomyMRPlist))$lengths > 1)]#
  # If there are duplicated columns (i.e., redundant MRP characters in the taxonomy):#
  if(length(duplicatedMRPstrings) > 0) {#
    # For each duplicated character:#
    for(i in duplicatedMRPstrings) {#
      # Get duplicated columns for current MRP string:#
      duplicatedcolumns <- which(TaxonomyMRPlist == i)#
      # Form new column name by collapsing higher taxa that are duplicated to a single string:#
      newcolumnname <- paste(names(duplicatedcolumns), collapse = "_et_")#
      # Overwrite first duplicated column name with new collapsed name:#
      colnames(TaxonomyMRP)[duplicatedcolumns[1]] <- newcolumnname#
      # Remove redundant columns from matrix:#
      TaxonomyMRP <- TaxonomyMRP[, -duplicatedcolumns[2:length(duplicatedcolumns)], drop = FALSE]#
      # Remove redundant columns from list:#
      TaxonomyMRPlist <- TaxonomyMRPlist[-duplicatedcolumns[2:length(duplicatedcolumns)]]#
    }#
  }#
  # Print current processing status:#
  cat("Done\nRemoving outgroups and empty supraspecific taxa...")#
  # Find any remaining taxa that now need to be deleted (outgroups to target clade and empty higher taxa):#
  TaxaToDelete <- setdiff(unlist(lapply(lapply(MRPList, '[[', 1), rownames)), NewValidOTUs)#
  # Find data sets with taxa to delete:#
  datasetswithtaxatodelete <- which(unlist(lapply(lapply(lapply(lapply(MRPList, '[[', 1), rownames), intersect, y = TaxaToDelete), length)) > 0)#
  # If there are such data sets:#
  if(length(datasetswithtaxatodelete) > 0) {#
    # For each data set with taxa to delete (done in reverse order in case deletions are found):#
    for(i in rev(datasetswithtaxatodelete)) {#
      # Collapse matrix to just valid OTUs:#
      MRPList[[i]]$matrix <- MRPList[[i]]$matrix[intersect(rownames(MRPList[[i]]$matrix), NewValidOTUs), , drop = FALSE]#
      # Get logical for how many characters are variable:#
      VariableCharacters <- unlist(lapply(lapply(lapply(apply(matrix(apply(MRPList[[i]]$matrix, 2, paste, collapse = "")), 1, strsplit, split = ""), unlist), unique), length)) > 1#
      # As long as there are variable characters:#
      if(any(VariableCharacters)) {#
        # If there are less than three taxa left collapse to a zero-column matrix:#
        if(nrow(MRPList[[i]]$matrix) < 3) MRPList[[i]]$matrix <- MRPList[[i]]$matrix[, -c(1:ncol(MRPList[[i]]$matrix)), drop = FALSE]#
        # If there are at least three taxa left (minimum for meaning) collapse to just meaningful:#
        if(nrow(MRPList[[i]]$matrix) >= 3) MRPList[[i]]$matrix <- MRPCollapse(MakeMorphMatrix(MRPList[[i]]$matrix, header = "", weights = rep(1, ncol(MRPList[[i]]$matrix)), ordering = rep("unord", ncol(MRPList[[i]]$matrix)), equalise.weights = FALSE))$matrix#
      # If there are no variable characters:#
      } else {#
        # Remove ith data set from MRP list (as has no meaningful characters):#
        MRPList <- MRPList[-i]#
      }#
    }#
  }#
  # Print current processing status:#
  cat("Done\nProducing taxonomy tree...")#
  # Duplicated Txonomy MRP to create a collapsable version for generating taxonomy Newick string:#
  TaxonomyMRPNewick <- TaxonomyMRP#
  # Get order of columns to collapse to form MRP#
  columncollapseorder <- order(apply(TaxonomyMRPNewick, 2, sum))#
  # For each column ("clade") in order from smallest to largest:#
  for(i in columncollapseorder) {#
    # Get taxa present in current clade:#
    taxonrows <- which(TaxonomyMRPNewick[, i] == 1)#
    # Create new partial Newick tsring for current clade (node):#
    newNewickstring <- paste("(", paste(names(taxonrows), collapse = ","), ")", colnames(TaxonomyMRPNewick)[i], sep = "")#
    # Replace row name with new Newick string:#
    rownames(TaxonomyMRPNewick)[taxonrows[1]] <- newNewickstring#
    # Remove now redundant taxa from Newick matrix:#
    TaxonomyMRPNewick <- TaxonomyMRPNewick[-taxonrows[2:length(taxonrows)], , drop = FALSE]#
  }#
  # Complete Newick string and over write Taxonomy Newick matrix:#
  TaxonomyMRPNewick <- paste("(", paste(rownames(TaxonomyMRPNewick), collapse = ","), ")", targetclade, ";", sep = "")#
  # Ladderize taxonomy tree for neatness!:#
  TaxonomyMRPTree <- ladderize(read.tree(text = TaxonomyMRPNewick))#
  # Print current processing status:#
  cat("Done\nAdding NAs for indet. and sp. subclades to taxonomy MRP...")#
  # Find indeterminates and sps:#
  indetsandsps <- NewValidOTUs[which((unlist(lapply(lapply(strsplit(NewValidOTUs, "_"), '==', "indet"), sum)) + unlist(lapply(lapply(strsplit(NewValidOTUs, "_"), '==', "sp"), sum))) > 0)]#
  # If there are indeterminates and/or sps:#
  if(length(indetsandsps) > 0) {#
    # For each such taxon:#
    for(i in indetsandsps) {#
      # Find higher taxon to which it belongs:#
      highertaxon <- colnames(TaxonomyMRP)[which(unlist(lapply(lapply(strsplit(colnames(TaxonomyMRP), "_et_"), '==', strsplit(i, "_")[[1]][1]), sum)) == 1)]#
      # Find any sub (suprapseicifc taxa) for that higher taxon:#
      subtaxa <- colnames(TaxonomyMRP)[which(unlist(lapply(lapply(lapply(split(TaxonomyMRP[names(which(TaxonomyMRP[, highertaxon] == 1)), , drop = FALSE], rep(1:ncol(TaxonomyMRP[names(which(TaxonomyMRP[, highertaxon] == 1)), , drop = FALSE]), each = nrow(TaxonomyMRP[names(which(TaxonomyMRP[, highertaxon] == 1)), , drop = FALSE]))), sort), unique), length)) == 2)]#
      # If these exist then set ith taxon as being NA with respect to belonging to the subtax(a):#
      if(length(subtaxa) > 1) TaxonomyMRP[i, subtaxa] <- NA#
    }#
  }#
  # Print current processing status:#
  cat("Done\nGetting weighting data (publication year and dependencies)...")#
  # Get publication years for each data set:#
  publicationyears <- as.numeric(gsub("[:a-z:]", "", gsub("inpress", strsplit(as.character(Sys.Date()), "-")[[1]][1], unlist(lapply(lapply(strsplit(names(MRPList), "_"), rev), '[', 1)))))#
  # Get parent (data set) data:#
  parentsdata <- unlist(lapply(MRPList, '[[', 2))#
  # Get sibling (data set) data:#
  siblingsdata <- unlist(lapply(MRPList, '[[', 3))#
  # Get multiple-offspring data sets:#
  multioffspringdatasets <- unique(sort(parentsdata[which(nchar(parentsdata) > 0)])[which(duplicated(sort(parentsdata[which(nchar(parentsdata) > 0)])))])#
  # If there are such data sets:#
  if(length(multioffspringdatasets) > 0) {#
    # Update siblings data accordingly:#
    for(i in multioffspringdatasets) siblingsdata[which(parentsdata == i)] <- paste(names(which(parentsdata == i)), collapse = "%%%%")#
  }#
  # Create pool of parents present amongst data sets (children of them must also be present by definition):#
  parentspresentinpool <- intersect(parentsdata, names(MRPList))#
  # Create empty vector to store data sets to remove from pool:#
  datasetstoremove <- vector(mode = "character")#
  # For each parent in pool:#
  for(i in parentspresentinpool) {#
    # Case if parent made redundant:#
    if(any(unlist(lapply(lapply(lapply(lapply(MRPList[which(parentsdata == i)], '[[', 1), rownames), setdiff, x = rownames(MRPList[[i]]$matrix)), length)) == 0)) {#
      # Add data set to remove list:#
      datasetstoremove <- c(datasetstoremove, i)#
    # Case if parent not redundant (becomes sibling):#
    } else {#
      # Update siblings data with parent:#
      siblingsdata[sort(c(i, names(MRPList[which(parentsdata == i)])))] <- paste(sort(c(names(MRPList[which(parentsdata == i)]), unlist(strsplit(siblingsdata[sort(c(i, names(MRPList[which(parentsdata == i)])))], "%%%%")))), collapse = "%%%%")#
    }#
  }#
  # Expunge data sets to remove from siblings lists:#
  siblingsdata <- unlist(lapply(lapply(lapply(lapply(siblingsdata, strsplit, split = "%%%%"), unlist), setdiff, y = datasetstoremove), paste, collapse = "%%%%"))#
  # Remove now redundant data sets from siblings:#
  siblingsdata <- siblingsdata[-match(datasetstoremove, names(MRPList))]#
  # Remove sibling relationships of size one (effectively pointless!):#
  if(length(intersect(which(nchar(siblingsdata) > 0), setdiff(c(1:length(siblingsdata)), grep("%%%%", siblingsdata)))) > 0) siblingsdata[intersect(which(nchar(siblingsdata) > 0), setdiff(c(1:length(siblingsdata)), grep("%%%%", siblingsdata)))] <- ""#
  # Remove now redundant data sets from publication years:#
  publicationyears <- publicationyears[-match(datasetstoremove, names(MRPList))]#
  # Remove now redundant data sets from MRP list:#
  MRPList <- MRPList[-match(datasetstoremove, names(MRPList))]#
  # Print current processing status:#
  cat("Done\nCalculating weights...")#
  # Equation 1 in Supplemenary Information of Lloyd et al. (2016):#
  publicationyearweights <- 10 * 2^(0.5 * (publicationyears - min(publicationyears)))#
  # Get indepenece weights (using siblings data):#
  independenceweights <- 1 / apply(rbind(rep(1, length(MRPList)), unlist(lapply(lapply(lapply(siblingsdata, strsplit, split = "%%%%"), unlist), length))), 2, max)#
  # Get N characters weight (to avoid ucnertain data sets swamping the signal):#
  Ncharacterweights <- 1 / apply(rbind(rep(1, length(MRPList)), unlist(lapply(lapply(MRPList, '[[', 1), ncol))), 2, max)#
  # Combine weights (just a product for now, but other options should be explored!:#
  publicationweights <- publicationyearweights * independenceweights * Ncharacterweights#
  # Make range of weights span 990 (difference between 10 and 1000):#
  publicationweights <- (1 / (diff(range(publicationweights)) / 990)) * publicationweights#
  # Make minimum weight 10 (and by extension maximum weight 1000):#
  publicationweights <- (10 - min(publicationweights)) + publicationweights#
  # Restrict weights to 2dp:#
  publicationweights <- round(publicationweights, 2)#
  # Print current processing status:#
  cat("Done\nBuilding MRP matrix...")#
  # Create empty full MRP matrix:#
  FullMRPMatrix <- matrix(nrow = length(NewValidOTUs), ncol = 0, dimnames = list(NewValidOTUs, c()))#
  # Create empty character weights vector:#
  characterweights <- vector(mode = "numeric")#
  # For each data set:#
  for(i in 1:length(MRPList)) {#
    # Find taxa not present in full matrix:#
    taxanotinmatrix <- setdiff(NewValidOTUs, rownames(MRPList[[i]]$matrix))#
    # Add data set block (including missing taxa as NAs) into full matrix:#
    FullMRPMatrix <- cbind(FullMRPMatrix, rbind(MRPList[[i]]$matrix, matrix(NA, nrow = length(taxanotinmatrix), ncol = ncol(MRPList[[i]]$matrix), dimnames = list(taxanotinmatrix, rep(names(MRPList)[i], ncol(MRPList[[i]]$matrix)))))[rownames(FullMRPMatrix), ])#
    # Add character weights using publication weights:#
    characterweights <- c(characterweights, rep(publicationweights[i], ncol(MRPList[[i]]$matrix)))#
  }#
  # Add taxonomy into matrix:#
  FullMRPMatrix <- cbind(FullMRPMatrix, TaxonomyMRP[rownames(FullMRPMatrix), ])#
  # Add taxonomy weights:#
  characterweights <- c(characterweights, rep(1, ncol(TaxonomyMRP)))#
  # Add all zero outgroup:#
  FullMRPMatrix <- rbind(rep("0", ncol(FullMRPMatrix)), FullMRPMatrix)#
  # Add all zero outgroup taxon name:#
  rownames(FullMRPMatrix)[1] <- "allzero"#
  # Convert into Claddis formatted matrix:#
  FullMRPMatrix <- MakeMorphMatrix(FullMRPMatrix, header = "", weights = characterweights, ordering = rep("ord", ncol(FullMRPMatrix)), equalise.weights = FALSE)#
  # Print current processing status:#
  cat("Done\nPerforming Safe Taxonomic Reduction...")
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
  # Create empty STR matrix:#
  STRmatrix <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c("Junior", "Senior")))#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # NEED TO CHANGE THIS TO A MORE EFFICIENT WHILE LOOP SO NOT ASLING FOR A CONDITIONAL OVER AND OVER)#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)
# Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  cbind(lapply(SafeToRemove, '[', 1), lapply(SafeToRemove, '[', 2))
rownames(FullMRPMatrix$matrix)
cbind(lapply(SafeToRemove, '[', 1), lapply(SafeToRemove, '[', 2))
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
  # Create empty STR matrix:#
  STRmatrix <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c("Junior", "Senior")))
rownames(morph.matrix)
rownames(morph.matrix$matrix)
rownumber <- 253
# First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])
# Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]
# Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }
MatrixBlockToCheck
cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)])
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
  # Create empty STR matrix:#
  STRmatrix <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c("Junior", "Senior")))#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)
SafeToRemove
# Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]
SafeToRemove
lapply(SafeToRemove, '[', 1)
lapply(SafeToRemove, '[', ,1)
cbind(lapply(SafeToRemove, '[', , 1), lapply(SafeToRemove, '[', , 2))
cbind(lapply(SafeToRemove, '[', ,1), lapply(SafeToRemove, '[', ,2))
lapply(SafeToRemove, '[', ,1)
cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
STRupdate(FullMRPMatrix)
?Claddis
Sys.time
Sys.time()
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
Start_CurrentSTR - End_CurrentSTR#
Start_NewSTR - End_NewSTR
x2time / x1time
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time / x1time
x1time
x1time[1]
x1time[[1]]
x2time[[1]] / x1time[[1]]
SafeTaxonomicReduction
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")
x1
x1$str.list
x2
Gauthier1986
MatrixBlockToCheck
apply(MatrixBlockToCheck, 1, is.na)
apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)
which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any))
names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time[[1]] / x1time[[1]]
x1$str.list
x2
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Sunfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
#
STRupdate(FullMRPMatrix)
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
#
STRupdate(FullMRPMatrix)#
#
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time[[1]] / x1time[[1]]
??SafeTaxonomicReduction
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")
STRRule <- c()#
  for(i in 1:nrow(SafeToRemove)) {#
  }
i
SafeToRemove[i]
morph.matrix$matrix[SafeToRemove[i], ]
morph.matrix$matrix[SafeToRemove[i, 1], ]#
    morph.matrix$matrix[SafeToRemove[i, 2], ]
morph.matrix$matrix[SafeToRemove[i, 1], ] == morph.matrix$matrix[SafeToRemove[i, 2], ]
paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")
# Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  STRRule <- c()#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      print("symmetric")#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      print("asymmetric")#
    }#
#
  }
is.na(morph.matrix$matrix[SafeToRemove[i, 1], ])
any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))
STRRule <- c()#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      # Check for any missing data (subrule b):#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        print("Rule1b")#
      # If no missing data is rule 1a:#
      } else {#
        print("Rule1a")#
      }#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      # Check for any missing data (subrule b):#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        print("Rule2b")#
      # If no missing data is rule 1a:#
      } else {#
        print("Rule2a")#
      }#
    }#
#
  }
x1$str.list
# Create empty vector to store rule data:#
  STRRule <- c()#
  # For each STR pair:#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 1b:#
        STRRule <- c(STRRule, "Rule 1B")#
      # If no missing data:#
      } else {#
        # Is rule 1a:#
        STRRule <- c(STRRule, "Rule 1A")#
      }#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 2B:#
        STRRule <- c(STRRule, "Rule 2B")#
      # If no missing data is rule 1a:#
      } else {#
        # Is rule 2A:#
        STRRule <- c(STRRule, "Rule 2A")#
      }#
    }#
#
  }
STRRule
x1$str.list
SafeToRemove <- cbind(SafeToRemove, STRRule)
SafeToRemove[1:2, ]
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Create empty vector to store rule data:#
  STRRule <- c()#
  # For each STR pair:#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 1b:#
        STRRule <- c(STRRule, "Rule 1B")#
      # If no missing data:#
      } else {#
        # Is rule 1a:#
        STRRule <- c(STRRule, "Rule 1A")#
      }#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 2B:#
        STRRule <- c(STRRule, "Rule 2B")#
      # If no missing data is rule 1a:#
      } else {#
        # Is rule 2A:#
        STRRule <- c(STRRule, "Rule 2A")#
      }#
    }#
#
  }#
  # Add rule to output:#
  SafeToRemove <- cbind(SafeToRemove, STRRule)#
  # Update column heading for rule:#
  colnames(SafeToRemove) <- "Rule"#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
#
STRupdate(FullMRPMatrix)#
#
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time[[1]] / x1time[[1]]
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Create empty vector to store rule data:#
  STRRule <- c()#
  # For each STR pair:#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 1b:#
        STRRule <- c(STRRule, "Rule 1B")#
      # If no missing data:#
      } else {#
        # Is rule 1a:#
        STRRule <- c(STRRule, "Rule 1A")#
      }#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 2B:#
        STRRule <- c(STRRule, "Rule 2B")#
      # If no missing data is rule 1a:#
      } else {#
        # Is rule 2A:#
        STRRule <- c(STRRule, "Rule 2A")#
      }#
    }#
#
  }
cbind(SafeToRemove, STRRule)
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # Collapse down to just those with data:#
  SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
  # Rebuild as matrix:#
  SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
  # Add column names:#
  colnames(SafeToRemove) <- c("Junior", "Senior")#
  # Create empty vector to store rule data:#
  STRRule <- c()#
  # For each STR pair:#
  for(i in 1:nrow(SafeToRemove)) {#
    # Check for rule 1 (symmetrical coding):#
    if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 1b:#
        STRRule <- c(STRRule, "Rule 1B")#
      # If no missing data:#
      } else {#
        # Is rule 1a:#
        STRRule <- c(STRRule, "Rule 1A")#
      }#
    # Must be rule 2 (asymmetric coding):#
    } else {#
      # Check for any missing data:#
      if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
        # Is rule 2B:#
        STRRule <- c(STRRule, "Rule 2B")#
      # If no missing data is rule 1a:#
      } else {#
        # Is rule 2A:#
        STRRule <- c(STRRule, "Rule 2A")#
      }#
    }#
#
  }#
  # Add rule to output:#
  SafeToRemove <- cbind(SafeToRemove, STRRule)#
  # Update column heading for rule:#
  colnames(SafeToRemove)[3] <- "Rule"#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
#
STRupdate(FullMRPMatrix)#
#
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time[[1]] / x1time[[1]]
x1
morph.matrix <- FullMRPMatrix
# Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)
Michaux1989
SafeTaxonomicReduction(Michaux1989)
SafeTaxonomicReduction
STRupdate(Michaux1989)
unlist(lapply(SafeToRemove, is.null))
all(unlist(lapply(SafeToRemove, is.null)))
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  if(all(unlist(lapply(SafeToRemove, is.null)))) {#
    # Create empty safe to remove matrix:#
    SafeToRemove <- matrix(nrow = 0, ncol = 3, dimnames = list(c(), c("junior", "Senior", "Rule")))#
    ReducedMatrix <- Unaltered$matrix#
    RemovedMatrix <- Unaltered$matrix[-(1:nrow(Unaltered$matrix)), , drop = FALSE]#
  # If there are taxa to be removed:#
  } else {#
    # Collapse down to just those with data:#
    SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
    # Rebuild as matrix:#
    SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
    # Add column names:#
    colnames(SafeToRemove) <- c("Junior", "Senior")#
    # Create empty vector to store rule data:#
    STRRule <- c()#
    # For each STR pair:#
    for(i in 1:nrow(SafeToRemove)) {#
      # Check for rule 1 (symmetrical coding):#
      if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 1b:#
          STRRule <- c(STRRule, "Rule 1B")#
        # If no missing data:#
        } else {#
          # Is rule 1a:#
          STRRule <- c(STRRule, "Rule 1A")#
        }#
      # Must be rule 2 (asymmetric coding):#
      } else {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 2B:#
          STRRule <- c(STRRule, "Rule 2B")#
        # If no missing data is rule 1a:#
        } else {#
          # Is rule 2A:#
          STRRule <- c(STRRule, "Rule 2A")#
        }#
      }#
    }#
    # Add rule to output:#
    SafeToRemove <- cbind(SafeToRemove, STRRule)#
    # Update column heading for rule:#
    colnames(SafeToRemove)[3] <- "Rule"#
  }#
  # Return safely removed taxa:#
  return(SafeToRemove)#
#
}#
STRupdate(Michaux1989)#
STRupdate(Gauthier1986)
SafeTaxonomicReduction(Michaux1989)
SafeTaxonomicReduction(gauthier1986)
SafeTaxonomicReduction(Gauthier1986)
names(SafeTaxonomicReduction(Gauthier1986))
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # If no taxa can be safely deleted:#
  if(all(unlist(lapply(SafeToRemove, is.null)))) {#
    # Warn user:#
    print("No taxa can be safely removed")#
    # Create empty safe to remove matrix:#
    SafeToRemove <- matrix(nrow = 0, ncol = 3, dimnames = list(c(), c("Junior", "Senior", "Rule")))#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[-(1:nrow(Unaltered$matrix)), , drop = FALSE]#
  # If there are taxa that can be deleted:#
  } else {#
    # Collapse down to just those with data:#
    SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
    # Rebuild as matrix:#
    SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
    # Add column names:#
    colnames(SafeToRemove) <- c("Junior", "Senior")#
    # Create empty vector to store rule data:#
    STRRule <- c()#
    # For each STR pair:#
    for(i in 1:nrow(SafeToRemove)) {#
      # Check for rule 1 (symmetrical coding):#
      if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 1b:#
          STRRule <- c(STRRule, "Rule 1B")#
        # If no missing data:#
        } else {#
          # Is rule 1a:#
          STRRule <- c(STRRule, "Rule 1A")#
        }#
      # Must be rule 2 (asymmetric coding):#
      } else {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 2B:#
          STRRule <- c(STRRule, "Rule 2B")#
        # If no missing data is rule 1a:#
        } else {#
          # Is rule 2A:#
          STRRule <- c(STRRule, "Rule 2A")#
        }#
      }#
    }#
    # Add rule to output:#
    SafeToRemove <- cbind(SafeToRemove, STRRule)#
    # Update column heading for rule:#
    colnames(SafeToRemove)[3] <- "Rule"#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[sort(unique(SafeToRemove[, "Junior"])), ]#
#
  }#
  ##
  output <- list(SafeToRemove, ReducedMatrix, RemovedMatrix)#
  names(output) <- c("str.list", "reduced.matrix", "removed.matrix")#
  # Return safely removed taxa:#
  return(output)#
#
}#
STRupdate(Michaux1989)#
STRupdate(Gauthier1986)
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # If no taxa can be safely deleted:#
  if(all(unlist(lapply(SafeToRemove, is.null)))) {#
    # Warn user:#
    print("No taxa can be safely removed")#
    # Create empty safe to remove matrix:#
    SafeToRemove <- matrix(nrow = 0, ncol = 3, dimnames = list(c(), c("Junior", "Senior", "Rule")))#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[-(1:nrow(Unaltered$matrix)), , drop = FALSE]#
  # If there are taxa that can be deleted:#
  } else {#
    # Collapse down to just those with data:#
    SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
    # Rebuild as matrix:#
    SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
    # Add column names:#
    colnames(SafeToRemove) <- c("Junior", "Senior")#
    # Create empty vector to store rule data:#
    STRRule <- c()#
    # For each STR pair:#
    for(i in 1:nrow(SafeToRemove)) {#
      # Check for rule 1 (symmetrical coding):#
      if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 1b:#
          STRRule <- c(STRRule, "Rule 1B")#
        # If no missing data:#
        } else {#
          # Is rule 1a:#
          STRRule <- c(STRRule, "Rule 1A")#
        }#
      # Must be rule 2 (asymmetric coding):#
      } else {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 2B:#
          STRRule <- c(STRRule, "Rule 2B")#
        # If no missing data is rule 1a:#
        } else {#
          # Is rule 2A:#
          STRRule <- c(STRRule, "Rule 2A")#
        }#
      }#
    }#
    # Add rule to output:#
    SafeToRemove <- cbind(SafeToRemove, STRRule)#
    # Update column heading for rule:#
    colnames(SafeToRemove)[3] <- "Rule"#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix[setdiff(rownames(Unaltered$matrix), unique(SafeToRemove[, "Junior"])), ]#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[sort(unique(SafeToRemove[, "Junior"])), ]#
#
  }#
  ##
  output <- list(SafeToRemove, ReducedMatrix, RemovedMatrix)#
  names(output) <- c("str.list", "reduced.matrix", "removed.matrix")#
  # Return safely removed taxa:#
  return(output)#
#
}#
STRupdate(Michaux1989)$reduced.matrix#
STRupdate(Gauthier1986)$reduced.matrix
SafeTaxonomicReduction
STRupdate <- function(morph.matrix) {#
  # Store unaltered version of matrix to return to later:#
  Unaltered <- morph.matrix#
  # Prune out any zero weight characters, if they exist:#
  if(any(morph.matrix$weights == 0)) morph.matrix <- MatrixPruner(clad.matrix = morph.matrix, characters2prune = which(morph.matrix$weights == 0))#
  # Order matrix from least to most complete taxon (as least is most likely to be removed):#
  morph.matrix$matrix <- morph.matrix$matrix[order(apply(apply(morph.matrix$matrix, 1, is.na), 2, sum), decreasing = TRUE), ]#
#
  # Subfunction to be used by lapply to check downwards (look at more complete taxa only) for safely removable taxa:#
  CheckDownwardForMatches <- function(rownumber, morph.matrix) {#
    # First find which characters are not scored as missing in current taxon:#
    NonMissingCharacters <- !is.na(morph.matrix$matrix[rownumber, ])#
    # Build isolated matrix block from current taxon to end of matrix only for characters coded for current taxon:#
    MatrixBlockToCheck <- morph.matrix$matrix[rownumber:nrow(morph.matrix$matrix), NonMissingCharacters, drop = FALSE]#
    # Find any taxa that have missing characters inside the block (can not be true parents):#
    TaxaWithMissingCharacters <- names(which(apply(apply(MatrixBlockToCheck, 1, is.na), 2, any)))#
    # If any taxa have missing characters inside the block (can not be true parents) remove them from the block:#
    if(length(TaxaWithMissingCharacters) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(TaxaWithMissingCharacters, rownames(MatrixBlockToCheck)), , drop = FALSE]#
    # Set start column (first character in matrix block):#
    StartColumn <- 1#
    # Set end column (last character in matrix block):#
    EndColumn <- ncol(MatrixBlockToCheck)#
    # As long as there is more potential seniors (more than one row in the matrix block) and there are still characters to check:#
    while(nrow(MatrixBlockToCheck) > 1 && StartColumn != (EndColumn + 1)) {#
      # Only look at rows where taxa are coded for the ith character:#
      NonMissingRows <- which(!is.na(MatrixBlockToCheck[2:nrow(MatrixBlockToCheck), StartColumn]))#
      # List any insafe taxa (i.e., those with a diffrent coding to the current taxon):#
      UnsafeTaxa <- names(which(MatrixBlockToCheck[(NonMissingRows + 1), StartColumn] != MatrixBlockToCheck[1, StartColumn]))#
      # Reduce the matrix block to just potential safe taxon parents (and the current taxon):#
      if(length(UnsafeTaxa) > 0) MatrixBlockToCheck <- MatrixBlockToCheck[-match(UnsafeTaxa, rownames(MatrixBlockToCheck)), , drop = FALSE]#
      # Iterate to next colum:#
      StartColumn <- StartColumn + 1#
    }#
    # If safe taxonomic reduction is possible store junior and senior(s):#
    if(nrow(MatrixBlockToCheck) > 1) return(cbind(rep(x = rownames(MatrixBlockToCheck)[1], times = nrow(MatrixBlockToCheck) - 1), rownames(MatrixBlockToCheck)[2:nrow(MatrixBlockToCheck)]))#
  }#
  # Get any safely removable taxa and their senior parents:#
  SafeToRemove <- lapply(as.list(1:(nrow(morph.matrix$matrix) - 1)), CheckDownwardForMatches, morph.matrix = morph.matrix)#
  # If no taxa can be safely deleted:#
  if(all(unlist(lapply(SafeToRemove, is.null)))) {#
    # Warn user:#
    print("No taxa can be safely removed")#
    # Create empty safe to remove matrix:#
    SafeToRemove <- matrix(nrow = 0, ncol = 3, dimnames = list(c(), c("Junior", "Senior", "Rule")))#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[-(1:nrow(Unaltered$matrix)), , drop = FALSE]#
  # If there are taxa that can be deleted:#
  } else {#
    # Collapse down to just those with data:#
    SafeToRemove <- SafeToRemove[which(!unlist(lapply(SafeToRemove, is.null)))]#
    # Rebuild as matrix:#
    SafeToRemove <- cbind(unlist(lapply(SafeToRemove, '[', ,1)), unlist(lapply(SafeToRemove, '[', ,2)))#
    # Add column names:#
    colnames(SafeToRemove) <- c("Junior", "Senior")#
    # Create empty vector to store rule data:#
    STRRule <- c()#
    # For each STR pair:#
    for(i in 1:nrow(SafeToRemove)) {#
      # Check for rule 1 (symmetrical coding):#
      if(paste(morph.matrix$matrix[SafeToRemove[i, 1], ], collapse = "") == paste(morph.matrix$matrix[SafeToRemove[i, 2], ], collapse = "")) {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 1b:#
          STRRule <- c(STRRule, "Rule 1B")#
        # If no missing data:#
        } else {#
          # Is rule 1a:#
          STRRule <- c(STRRule, "Rule 1A")#
        }#
      # Must be rule 2 (asymmetric coding):#
      } else {#
        # Check for any missing data:#
        if(any(is.na(morph.matrix$matrix[SafeToRemove[i, 1], ]))) {#
          # Is rule 2B:#
          STRRule <- c(STRRule, "Rule 2B")#
        # If no missing data is rule 1a:#
        } else {#
          # Is rule 2A:#
          STRRule <- c(STRRule, "Rule 2A")#
        }#
      }#
    }#
    # Add rule to output:#
    SafeToRemove <- cbind(SafeToRemove, STRRule)#
    # Update column heading for rule:#
    colnames(SafeToRemove)[3] <- "Rule"#
    # Set reduced matrix as complete matrix:#
    ReducedMatrix <- Unaltered$matrix[setdiff(rownames(Unaltered$matrix), unique(SafeToRemove[, "Junior"])), ]#
    # Set removed matrix as empty matrix:#
    RemovedMatrix <- Unaltered$matrix[sort(unique(SafeToRemove[, "Junior"])), ]#
#
  }#
  # Compile output into single list:#
  output <- list(SafeToRemove, ReducedMatrix, RemovedMatrix)#
  # Add names to output:#
  names(output) <- c("str.list", "reduced.matrix", "removed.matrix")#
  # Return output inviisibly:#
  return(invisible(output))#
#
}#
STRupdate(Michaux1989)$reduced.matrix#
STRupdate(Gauthier1986)$reduced.matrix#
#
STRupdate(FullMRPMatrix)#
#
Start_CurrentSTR <- Sys.time()#
x1 <- SafeTaxonomicReduction(Gauthier1986)#
End_CurrentSTR <- Sys.time()#
#
Start_NewSTR <- Sys.time()#
x2 <- STRupdate(Gauthier1986)#
End_NewSTR <- Sys.time()#
#
x1time <- End_CurrentSTR - Start_CurrentSTR#
x2time <- End_NewSTR - Start_NewSTR#
#
x2time[[1]] / x1time[[1]]
x2$str.list
library(devtools)
setwd("~/Documents/Packages/Claddis/Claddis")
check()
