#' Creates a morphological matrix object from a matrix
#' 
#' Transforms a single matrix into a list typically generated by the \link{ReadMorphNexus} function.
#' 
#' @param matrix A discrete morphological characters matrix with rows as OTUs and columns as characters.
#' @param header An optional header text usually included in a \code{#NEXUS} file given between square brackets as character. If no provided, the header is set to be \code{""} (empty quotes).
#' @param ordering An optional vector of \code{"unord"} and \code{"ord"} character strings of the same length as the number of columns in the \code{matrix} argument. If not provided, all characters are assumed to be \code{"unord"}.
#' @param weights An optional of \code{numeric} values of the same length as the number of columns in the \code{matrix} argument. If not provided, all characters are assumed to be \code{1}.
#' @param step.matrices An optional list of step matrices (default = \code{NULL}).
#' @param combine.morph.matrix An optional character-taxon matrix in the format imported by \link{ReadMorphNexus} to combine with the \code{matrix} argument.
#' 
#' @details
#' The \code{max.vals} and \code{min.vals} elements are automatically calculated from the input \code{matrix} argument.
#' 
## TG: This bit is just copy pasted from the ReadMorphNexus manual
#' @return
#' \item{header}{Any header text included in the file given between square brackets as character.}
#' \item{matrix}{A matrix of taxa (rows) and characters (columns). The matrix is in character format in order to deal with polymorphisms, which are separated by ampersands.}
#' \item{ordering}{A character vector of the same length as the number of morphological characters indicating whether they are ordered (\code{ORD}) or unordered (\code{UNORD}).}
#' \item{weights}{A numeric vector of the same length as the number of morphological characters indicating their weights.}
#' \item{max.vals}{A numeric vector of the same length as the number of morphological characters indicating the maximum state values.}
#' \item{min.vals}{A numeric vector of the same length as the number of morphological characters indicating the minimum state values.}
#' \item{step.matrices}{A list of any step matrices supplied in the input file. Is \code{NULL} if none are specified.}
#' \item{symbols}{The original symbols used in the input data (these are replaced here by the digits 0-9 and the letters A-V in order).}
#' 
#' @author Thomas Guillerme \email{guillert@@tcd.ie}
#'
#' @seealso \link{ReadMorphNexus}, \link{WriteMorphNexus}
#' 
#' @examples
#' 
#' ## Estimating ancestral states for the nodes of a matrix
#' # Set random seed:
#' set.seed(17)
#' 
#' # Generate a random tree for the Michaux data set:
#' tree <- rtree(nrow(Michaux1989$matrix))
#' 
#' # Update taxon names to match those in the data matrix:
#' tree$tip.label <- rownames(Michaux1989$matrix)
#' 
#' # Set root time by making youngest taxon extant:
#' tree$root.time <- max(diag(vcv(tree)))
#' 
#' # Estimate ancestral states:
#' matrix_nodes_estimates <- AncStateEstMatrix(Michaux1989, tree)
#' 
#' ## Transform the matrix of ancestral nodes states into a ReadMorphNexus list
#' MakeMorphNexus(matrix_nodes_estimates)
#' 
#' ## Combine it with the original matrix (containing the tips)
#' MakeMorphNexus(matrix_nodes_estimates, combine.morph.matrix = Michaux1989)
#' 
#' @export MakeMorphNexus

MakeMorphMatrix <- function(matrix, header, ordering, weights, step.matrices, combine.morph.matrix) {

    #~~~~~
    # SANITIZING FUNCTIONS, NO NEED TO EXPORT THEM
    #~~~~~

    # Function for checking the class of an object (if error, returns error message targeting the object).
    check.class <- function(object, class, msg, errorif=FALSE) {
        #Set default msg (if missing)
        if(missing(msg)) {
            msg <- paste(" must be of class: ", class, ".", sep="")
        }

        #Get function's call
        match_call <- match.call()

        #If only one class is provided, check if object is from this class
        if(length(class) == 1) {
            if(errorif == FALSE) {
                #Error must be returned if object *IS NOT* class
                if(class(object) != class) {
                    stop(match_call$object, msg , call.=FALSE)
                }
            } else {
                #Error must be returned if object *IS* class
                if(class(object) == class) {
                    stop(match_call$object, msg , call.=FALSE)
                }        
            }

        } else {
        
        #If more classes are provided, check if the object is from one of these classes (class[1] else class[2] else class[3], etc..). Returns error only if object is not of any class
            for (i in 1:length(class)) {
                if(class(object) == class[i]) {
                    class.test<-class[i]
                }        
            }
            if(exists(as.character(quote(class.test)))) {
                return(class.test)
            } else {
                stop(match_call$object, msg , call.=FALSE)
            }
        }
    }

    # Function for checking the class of an object (if error, returns error message targeting the object).
    check.length <- function(object, length, msg, errorif=FALSE) {

         #Get function's call
        match_call<-match.call()

        if(errorif==FALSE) {
            #Error must be returned if object *IS NOT* of right length
            if(length(object) != length) {
                stop(match_call$object, msg , call.=FALSE)
            }
        } else {
            #Error must be returned if object *IS* of right length
            if(length(object) == length) {
                stop(match_call$object, msg , call.=FALSE)
            }        
        }
    }

    #Get function's call
    match_call <- match.call()

    #~~~~~
    #SANITIZING
    #~~~~~

    #"matrix" argument
    #Check class
    check.class(matrix, "matrix")

    #If "combine.morph.matrix" argument exists
    if(!missing(combine.morph.matrix)) {
        #Check if both matrices have the same number of columns (i.e. characters):
        if(ncol(matrix) == ncol(combine.morph.matrix$matrix)) {
            #Use the parameters from the "combine.morph.matrix" argument
            header <- combine.morph.matrix$header
            ordering <- combine.morph.matrix$ordering
            weights <- combine.morph.matrix$weights
            step.matrices <- combine.morph.matrix$step.matrices

            #Combine the matrices
            matrix <- rbind(Michaux1989$matrix, matrix)

        } else {
            #Error message!
            stop(paste(match_call$matrix, "and", match_call$combine.morph.matrix, "must have the same number of columns!"), call.=FALSE)
        }

    } else {
    #If "combine.morph.matrix" argument does not exists
        #Check the arguments validity:

        #"header" argument
        if(missing(header)) {
            #Set to default if missing
            header <- ""
        } else {
            #Else check class and length
            check.class(header, "character")
            check.length(header, 1, " must be a single character string.", errorif=FALSE)
        }

        #"ordering" argument
        if(missing(ordering)) {
            #Set to default if missing
            ordering <- rep("unord", ncol(matrix))
        } else {
            #Else check class and length
            check.class(ordering, "character")
            check.length(ordering, ncol(matrix), " must be the same length as the matrix.", errorif=FALSE)
            #Check if all values in ordering are either "unord" and/or "ord"
            options(warn =- 1)
            if(any(ordering != c("unord", "ord"))) {
                stop("Ordering vector must contain only 'unord' or/and 'ord' values.")
            }
            options(warn = 0)
        }

        #"weights" argument
        if(missing(weights)) {
            #Set to default if missing
            weights <- rep(1, ncol(matrix))
        } else {
            #Else check class and length
            check.class(weights, "integer")
            check.length(weights, ncol(matrix), " must be the same length as the matrix.", errorif=FALSE)
        }

        #"step.matrices" argument
        if(missing(step.matrices)) {
            #Set to default if missing
            step.matrices <- NULL
        }
    }


    #BUILD THE MORPHNEXUS OBJECT
    morph_nexus<-list()
    morph_nexus$header <- header
    morph_nexus$matrix <- matrix
    morph_nexus$ordering <- ordering
    morph_nexus$weights <- weights
    morph_nexus$max.vals <- apply(matrix, 2, max, na.rm=TRUE)
    morph_nexus$min.vals <- apply(matrix, 2, min, na.rm=TRUE)
    if(is.null(step.matrices)) {
        morph_nexus[7] <- list(NULL)
        names(morph_nexus)[7] <- "step.matrices"
    } else {
        morph_nexus$step.matrices <- step.matrices
    }
    morph_nexus$symbols <- as.character(unique(as.vector(matrix)))

    return(morph_nexus)
}
